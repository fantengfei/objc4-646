diff --git a/include/Block_private.h b/include/Block_private.h
new file mode 100755
index 0000000..f6d40d6
--- /dev/null
+++ b/include/Block_private.h
@@ -0,0 +1,219 @@
+/*
+ * Block_private.h
+ *
+ * SPI for Blocks
+ *
+ * Copyright (c) 2008-2010 Apple Inc. All rights reserved.
+ *
+ * @APPLE_LLVM_LICENSE_HEADER@
+ *
+ */
+
+#ifndef _BLOCK_PRIVATE_H_
+#define _BLOCK_PRIVATE_H_
+
+#include <Availability.h>
+#include <AvailabilityMacros.h>
+#include <TargetConditionals.h>
+
+#include <stdbool.h>
+#include <stdio.h>
+
+#include <Block.h>
+
+#if __cplusplus
+extern "C" {
+#endif
+
+
+
+enum {
+    BLOCK_DEALLOCATING =      (0x0001),  // runtime
+    BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime
+    BLOCK_NEEDS_FREE =        (1 << 24), // runtime
+    BLOCK_HAS_COPY_DISPOSE =  (1 << 25), // compiler
+    BLOCK_HAS_CTOR =          (1 << 26), // compiler: helpers have C++ code
+    BLOCK_IS_GC =             (1 << 27), // runtime
+    BLOCK_IS_GLOBAL =         (1 << 28), // compiler
+    BLOCK_USE_STRET =         (1 << 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE
+    BLOCK_HAS_SIGNATURE  =    (1 << 30)  // compiler
+};
+
+// revised new layout
+
+#define BLOCK_DESCRIPTOR_1 1
+struct Block_descriptor_1 {
+    unsigned long int reserved;
+    unsigned long int size;
+};
+
+#define BLOCK_DESCRIPTOR_2 1
+struct Block_descriptor_2 {
+    // requires BLOCK_HAS_COPY_DISPOSE
+    void (*copy)(void *dst, const void *src);
+    void (*dispose)(const void *);
+};
+
+#define BLOCK_DESCRIPTOR_3 1
+struct Block_descriptor_3 {
+    // requires BLOCK_HAS_SIGNATURE
+    const char *signature;
+    const char *layout;
+};
+
+struct Block_layout {
+    void *isa;
+    volatile int flags; // contains ref count
+    int reserved; 
+    void (*invoke)(void *, ...);
+    struct Block_descriptor_1 *descriptor;
+    // imported variables
+};
+
+
+struct Block_byref {
+    void *isa;
+    struct Block_byref *forwarding;
+    volatile int flags; // contains ref count
+    unsigned int size;
+    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
+    void (*byref_destroy)(struct Block_byref *);
+    // long shared[0];
+};
+
+struct Block_byref_header {
+    void *isa;
+    struct Block_byref *forwarding;
+    int flags;
+    unsigned int size;
+};
+
+
+// Runtime support functions used by compiler when generating copy/dispose helpers
+
+enum {
+    // see function implementation for a more complete description of these fields and combinations
+    BLOCK_FIELD_IS_OBJECT   =  3,  // id, NSObject, __attribute__((NSObject)), block, ...
+    BLOCK_FIELD_IS_BLOCK    =  7,  // a block variable
+    BLOCK_FIELD_IS_BYREF    =  8,  // the on stack structure holding the __block variable
+    BLOCK_FIELD_IS_WEAK     = 16,  // declared __weak, only used in byref copy helpers
+    BLOCK_BYREF_CALLER      = 128, // called from __block (byref) copy/dispose support routines.
+};
+
+enum {
+    BLOCK_ALL_COPY_DISPOSE_FLAGS = 
+        BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_BYREF |
+        BLOCK_FIELD_IS_WEAK | BLOCK_BYREF_CALLER
+};
+
+// Runtime entry point called by compiler when assigning objects inside copy helper routines
+BLOCK_EXPORT void _Block_object_assign(void *destAddr, const void *object, const int flags);
+    // BLOCK_FIELD_IS_BYREF is only used from within block copy helpers
+
+
+// runtime entry point called by the compiler when disposing of objects inside dispose helper routine
+BLOCK_EXPORT void _Block_object_dispose(const void *object, const int flags);
+
+
+
+// Other support functions
+
+// runtime entry to get total size of a closure
+BLOCK_EXPORT size_t Block_size(void *aBlock);
+
+// indicates whether block was compiled with compiler that sets the ABI related metadata bits
+BLOCK_EXPORT bool _Block_has_signature(void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+// returns TRUE if return value of block is on the stack, FALSE otherwise
+BLOCK_EXPORT bool _Block_use_stret(void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+// Returns a string describing the block's parameter and return types.
+// The encoding scheme is the same as Objective-C @encode.
+// Returns NULL for blocks compiled with some compilers.
+BLOCK_EXPORT const char * _Block_signature(void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+// Returns a string describing the block's GC layout.
+// Returns NULL for blocks compiled with some compilers.
+BLOCK_EXPORT const char * _Block_layout(void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+// Callable only from the ARR weak subsystem while in exclusion zone
+BLOCK_EXPORT bool _Block_tryRetain(const void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+// Callable only from the ARR weak subsystem while in exclusion zone
+BLOCK_EXPORT bool _Block_isDeallocating(const void *aBlock)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
+
+
+// the raw data space for runtime classes for blocks
+// class+meta used for stack, malloc, and collectable based blocks
+BLOCK_EXPORT void * _NSConcreteMallocBlock[32]
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
+BLOCK_EXPORT void * _NSConcreteAutoBlock[32]
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
+BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32]
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
+BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32]
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
+// declared in Block.h
+// BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
+// BLOCK_EXPORT void * _NSConcreteStackBlock[32];
+
+
+// the intercept routines that must be used under GC
+BLOCK_EXPORT void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                                  void (*setHasRefcount)(const void *, const bool),
+                                  void (*gc_assign_strong)(void *, void **),
+                                  void (*gc_assign_weak)(const void *, void *),
+                                  void (*gc_memmove)(void *, void *, unsigned long));
+
+// earlier version, now simply transitional
+BLOCK_EXPORT void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                                  void (*setHasRefcount)(const void *, const bool),
+                                  void (*gc_assign_strong)(void *, void **),
+                                  void (*gc_assign_weak)(const void *, void *));
+
+BLOCK_EXPORT void _Block_use_RR( void (*retain)(const void *),
+                                 void (*release)(const void *));
+
+struct Block_callbacks_RR {
+    size_t  size;                   // size == sizeof(struct Block_callbacks_RR)
+    void  (*retain)(const void *);
+    void  (*release)(const void *);
+    void  (*destructInstance)(const void *);
+};
+typedef struct Block_callbacks_RR Block_callbacks_RR;
+
+BLOCK_EXPORT void _Block_use_RR2(const Block_callbacks_RR *callbacks);
+
+// make a collectable GC heap based Block.  Not useful under non-GC.
+BLOCK_EXPORT void *_Block_copy_collectable(const void *aBlock);
+
+// thread-unsafe diagnostic
+BLOCK_EXPORT const char *_Block_dump(const void *block);
+
+
+// Obsolete
+
+// first layout
+struct Block_basic {
+    void *isa;
+    int Block_flags;  // int32_t
+    int Block_size; // XXX should be packed into Block_flags
+    void (*Block_invoke)(void *);
+    void (*Block_copy)(void *dst, void *src);  // iff BLOCK_HAS_COPY_DISPOSE
+    void (*Block_dispose)(void *);             // iff BLOCK_HAS_COPY_DISPOSE
+    //long params[0];  // where const imports, __block storage references, etc. get laid down
+};
+
+
+#if __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/include/CrashReporterClient.h b/include/CrashReporterClient.h
new file mode 100755
index 0000000..1c9c61a
--- /dev/null
+++ b/include/CrashReporterClient.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2010 Apple Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/***********************************************************************
+ * Not to be installed in /usr/local/include
+ ***********************************************************************/
+
+#ifndef _LIBC_CRASHREPORTERCLIENT_H
+#define _LIBC_CRASHREPORTERCLIENT_H
+
+#ifdef LIBC_NO_LIBCRASHREPORTERCLIENT
+
+/* Fake the CrashReporterClient API */
+#define CRGetCrashLogMessage() 0
+#define CRSetCrashLogMessage(x) /* nothing */
+#define CRSetCrashLogMessage2(x) /* nothing */
+
+#else /* !LIBC_NO_LIBCRASHREPORTERCLIENT */
+
+/* Include the real CrashReporterClient.h */
+#include_next <CrashReporterClient.h>
+
+#endif /* !LIBC_NO_LIBCRASHREPORTERCLIENT */
+
+#endif /* _LIBC_CRASHREPORTERCLIENT_H */
diff --git a/include/System/i386/cpu_capabilities.h b/include/System/i386/cpu_capabilities.h
new file mode 100755
index 0000000..470e8a3
--- /dev/null
+++ b/include/System/i386/cpu_capabilities.h
@@ -0,0 +1,312 @@
+/*
+ * Copyright (c) 2003-2009 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	PRIVATE
+
+#ifndef _I386_CPU_CAPABILITIES_H
+#define _I386_CPU_CAPABILITIES_H
+
+#ifndef	__ASSEMBLER__
+#include <stdint.h>
+#endif
+ 
+/*
+ * This API only supported for Apple internal use.
+ */
+
+/* Bit definitions for _cpu_capabilities: */
+
+#define	kHasMMX				0x00000001
+#define	kHasSSE				0x00000002
+#define	kHasSSE2			0x00000004
+#define	kHasSSE3			0x00000008
+#define	kCache32			0x00000010	/* cache line size is 32 bytes */
+#define	kCache64			0x00000020
+#define	kCache128			0x00000040
+#define	kFastThreadLocalStorage		0x00000080	/* TLS ptr is kept in a user-mode-readable register */
+#define kHasSupplementalSSE3		0x00000100
+#define	k64Bit				0x00000200	/* processor supports EM64T (not what mode you're running in) */
+#define	kHasSSE4_1			0x00000400
+#define	kHasSSE4_2			0x00000800
+#define	kHasAES				0x00001000
+#define	kInOrderPipeline		0x00002000	/* in-order execution */
+#define	kSlow				0x00004000	/* tsc < nanosecond */
+#define	kUP				0x00008000	/* set if (kNumCPUs == 1) */
+#define	kNumCPUs			0x00FF0000	/* number of CPUs (see _NumCPUs() below) */
+
+#define	kNumCPUsShift			16		/* see _NumCPUs() below */
+
+#ifndef	__ASSEMBLER__
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+extern int  _get_cpu_capabilities( void );
+__END_DECLS
+
+inline static
+int _NumCPUs( void )
+{
+	return (_get_cpu_capabilities() & kNumCPUs) >> kNumCPUsShift;
+}
+
+#endif /* __ASSEMBLER__ */
+
+
+/*
+ * The shared kernel/user "comm page(s)":
+ *
+ * The last several pages of every address space are reserved for the kernel/user
+ * "comm area". During system initialization, the kernel populates the comm pages with
+ * code customized for the particular processor and platform.
+ *
+ * Because Mach VM cannot map the last page of an address space, we don't use it.
+ */
+ 
+#define	_COMM_PAGE32_AREA_LENGTH	( 19 * 4096 )				/* reserved length of entire comm area */
+#define _COMM_PAGE32_BASE_ADDRESS	( 0xfffec000 )				/* base address of allocated memory, -20 pages */
+#define _COMM_PAGE32_START_ADDRESS	( 0xffff0000 )				/* address traditional commpage code starts on, -16 pages */
+#define _COMM_PAGE32_AREA_USED		( 19 * 4096 )				/* this is the amt actually allocated */
+#define _COMM_PAGE32_SIGS_OFFSET	0x8000					/* offset to routine signatures */
+
+#define	_COMM_PAGE64_AREA_LENGTH	( 2 * 1024 * 1024 )			/* reserved length of entire comm area (2MB) */
+#define _COMM_PAGE64_BASE_ADDRESS	( 0x00007fffffe00000ULL )		/* base address of allocated memory */
+#define _COMM_PAGE64_START_ADDRESS	( _COMM_PAGE64_BASE_ADDRESS )		/* address traditional commpage code starts on */
+#define _COMM_PAGE64_AREA_USED		( 2 * 4096 )				/* this is the amt actually populated */
+
+/* no need for an Objective-C area on Intel */
+#define _COMM_PAGE32_OBJC_SIZE		0ULL
+#define _COMM_PAGE32_OBJC_BASE		0ULL
+#define _COMM_PAGE64_OBJC_SIZE		0ULL
+#define _COMM_PAGE64_OBJC_BASE		0ULL
+
+#ifdef KERNEL_PRIVATE
+
+/* Inside the kernel, comm page addresses are absolute addresses
+ * assuming they are a part of the 32-bit commpage. They may
+ * be mapped somewhere else, especially for the 64-bit commpage.
+ */
+#define _COMM_PAGE_START_ADDRESS	_COMM_PAGE32_START_ADDRESS
+#define _COMM_PAGE_SIGS_OFFSET		_COMM_PAGE32_SIGS_OFFSET
+
+#else /* !KERNEL_PRIVATE */
+
+#if defined(__i386__)
+
+#define	_COMM_PAGE_AREA_LENGTH		_COMM_PAGE32_AREA_LENGTH
+#define _COMM_PAGE_BASE_ADDRESS		_COMM_PAGE32_BASE_ADDRESS
+#define _COMM_PAGE_START_ADDRESS	_COMM_PAGE32_START_ADDRESS
+#define _COMM_PAGE_AREA_USED		_COMM_PAGE32_AREA_USED
+#define _COMM_PAGE_SIGS_OFFSET		_COMM_PAGE32_SIGS_OFFSET
+
+#elif defined(__x86_64__)
+
+#define	_COMM_PAGE_AREA_LENGTH		_COMM_PAGE64_AREA_LENGTH
+#define _COMM_PAGE_BASE_ADDRESS		_COMM_PAGE64_BASE_ADDRESS
+#define _COMM_PAGE_START_ADDRESS	_COMM_PAGE64_START_ADDRESS
+#define _COMM_PAGE_AREA_USED		_COMM_PAGE64_AREA_USED
+
+#else
+#error architecture not supported
+#endif
+ 
+#endif /* !KERNEL_PRIVATE */
+
+/* data in the comm page */
+ 
+#define _COMM_PAGE_SIGNATURE		(_COMM_PAGE_START_ADDRESS+0x000)	/* first few bytes are a signature */
+#define _COMM_PAGE_VERSION		(_COMM_PAGE_START_ADDRESS+0x01E)	/* 16-bit version# */
+#define _COMM_PAGE_THIS_VERSION		11					/* version of the commarea format */
+  
+#define _COMM_PAGE_CPU_CAPABILITIES	(_COMM_PAGE_START_ADDRESS+0x020)	/* uint32_t _cpu_capabilities */
+#define _COMM_PAGE_NCPUS		(_COMM_PAGE_START_ADDRESS+0x022)	/* uint8_t number of configured CPUs */
+#define _COMM_PAGE_CACHE_LINESIZE	(_COMM_PAGE_START_ADDRESS+0x026)	/* uint16_t cache line size */
+
+#define _COMM_PAGE_SCHED_GEN		(_COMM_PAGE_START_ADDRESS+0x028)	/* uint32_t scheduler generation number (count of pre-emptions) */
+#define _COMM_PAGE_MEMORY_PRESSURE	(_COMM_PAGE_START_ADDRESS+0x02c)	/* uint32_t copy of vm_memory_pressure */
+#define	_COMM_PAGE_SPIN_COUNT		(_COMM_PAGE_START_ADDRESS+0x030)	/* uint32_t max spin count for mutex's */
+
+#define _COMM_PAGE_UNUSED1		(_COMM_PAGE_START_ADDRESS+0x034)	/* 12 unused bytes */
+
+#ifdef KERNEL_PRIVATE
+
+/* slots defined in all cases, but commpage setup code must not populate for 64-bit commpage */
+#define _COMM_PAGE_2_TO_52		(_COMM_PAGE_START_ADDRESS+0x040)	/* double float constant 2**52 */
+#define _COMM_PAGE_10_TO_6		(_COMM_PAGE_START_ADDRESS+0x048)	/* double float constant 10**6 */
+
+#else /* !KERNEL_PRIVATE */
+
+#if defined(__i386__)								/* following are not defined in 64-bit */
+#define _COMM_PAGE_2_TO_52		(_COMM_PAGE_START_ADDRESS+0x040)	/* double float constant 2**52 */
+#define _COMM_PAGE_10_TO_6		(_COMM_PAGE_START_ADDRESS+0x048)	/* double float constant 10**6 */
+#else
+#define _COMM_PAGE_UNUSED2		(_COMM_PAGE_START_ADDRESS+0x040)	/* 16 unused bytes */
+#endif
+
+#endif /* !KERNEL_PRIVATE */
+
+#define	_COMM_PAGE_TIME_DATA_START	(_COMM_PAGE_START_ADDRESS+0x050)	/* base of offsets below (_NT_SCALE etc) */
+#define _COMM_PAGE_NT_TSC_BASE		(_COMM_PAGE_START_ADDRESS+0x050)	/* used by nanotime() */
+#define _COMM_PAGE_NT_SCALE		(_COMM_PAGE_START_ADDRESS+0x058)	/* used by nanotime() */
+#define _COMM_PAGE_NT_SHIFT		(_COMM_PAGE_START_ADDRESS+0x05c)	/* used by nanotime() */
+#define _COMM_PAGE_NT_NS_BASE		(_COMM_PAGE_START_ADDRESS+0x060)	/* used by nanotime() */
+#define _COMM_PAGE_NT_GENERATION	(_COMM_PAGE_START_ADDRESS+0x068)	/* used by nanotime() */
+#define _COMM_PAGE_GTOD_GENERATION	(_COMM_PAGE_START_ADDRESS+0x06c)	/* used by gettimeofday() */
+#define _COMM_PAGE_GTOD_NS_BASE		(_COMM_PAGE_START_ADDRESS+0x070)	/* used by gettimeofday() */
+#define _COMM_PAGE_GTOD_SEC_BASE	(_COMM_PAGE_START_ADDRESS+0x078)	/* used by gettimeofday() */
+
+/* Warning: kernel commpage.h has a matching c typedef for the following.  They must be kept in sync.  */
+/* These offsets are from _COMM_PAGE_TIME_DATA_START */
+
+#define	_NT_TSC_BASE			0
+#define	_NT_SCALE			8
+#define	_NT_SHIFT			12
+#define	_NT_NS_BASE			16
+#define	_NT_GENERATION			24
+#define	_GTOD_GENERATION		28
+#define	_GTOD_NS_BASE			32
+#define	_GTOD_SEC_BASE			40
+ 
+ /* jump table (jmp to this address, which may be a branch to the actual code somewhere else) */
+ /* When new jump table entries are added, corresponding symbols should be added below        */
+ /* New slots should be allocated with at least 16-byte alignment. Some like bcopy require    */
+ /* 32-byte alignment, and should be aligned as such in the assembly source before they are relocated */
+#define _COMM_PAGE_COMPARE_AND_SWAP32   (_COMM_PAGE_START_ADDRESS+0x080)	/* compare-and-swap word */
+#define _COMM_PAGE_COMPARE_AND_SWAP64   (_COMM_PAGE_START_ADDRESS+0x0c0)	/* compare-and-swap doubleword */
+#define _COMM_PAGE_ENQUEUE              (_COMM_PAGE_START_ADDRESS+0x100)	/* enqueue */
+#define _COMM_PAGE_DEQUEUE              (_COMM_PAGE_START_ADDRESS+0x140)	/* dequeue */
+#define _COMM_PAGE_MEMORY_BARRIER       (_COMM_PAGE_START_ADDRESS+0x180)	/* memory barrier */
+#define _COMM_PAGE_ATOMIC_ADD32         (_COMM_PAGE_START_ADDRESS+0x1a0)	/* add atomic word */
+#define _COMM_PAGE_ATOMIC_ADD64         (_COMM_PAGE_START_ADDRESS+0x1c0)	/* add atomic doubleword */
+
+#define	_COMM_PAGE_CPU_NUMBER		(_COMM_PAGE_START_ADDRESS+0x1e0)	/* user-level cpu_number() */
+
+#define _COMM_PAGE_ABSOLUTE_TIME	(_COMM_PAGE_START_ADDRESS+0x200)	/* mach_absolute_time() */
+#define _COMM_PAGE_SPINLOCK_TRY		(_COMM_PAGE_START_ADDRESS+0x220)	/* spinlock_try() */
+#define _COMM_PAGE_SPINLOCK_LOCK	(_COMM_PAGE_START_ADDRESS+0x260)	/* spinlock_lock() */
+#define _COMM_PAGE_SPINLOCK_UNLOCK	(_COMM_PAGE_START_ADDRESS+0x2a0)	/* spinlock_unlock() */
+#define _COMM_PAGE_PTHREAD_GETSPECIFIC  (_COMM_PAGE_START_ADDRESS+0x2c0)	/* pthread_getspecific() */
+#define _COMM_PAGE_GETTIMEOFDAY		(_COMM_PAGE_START_ADDRESS+0x2e0)	/* used by gettimeofday() */
+#define _COMM_PAGE_FLUSH_DCACHE		(_COMM_PAGE_START_ADDRESS+0x4e0)	/* sys_dcache_flush() */
+#define _COMM_PAGE_FLUSH_ICACHE		(_COMM_PAGE_START_ADDRESS+0x520)	/* sys_icache_invalidate() */
+#define _COMM_PAGE_PTHREAD_SELF		(_COMM_PAGE_START_ADDRESS+0x580)	/* pthread_self() */
+
+#define _COMM_PAGE_PREEMPT		(_COMM_PAGE_START_ADDRESS+0x5a0)	/* used by PFZ code */
+
+#define _COMM_PAGE_RELINQUISH		(_COMM_PAGE_START_ADDRESS+0x5c0)	/* used by spinlocks */ 
+#define _COMM_PAGE_BTS		        (_COMM_PAGE_START_ADDRESS+0x5e0)	/* bit test-and-set */
+#define _COMM_PAGE_BTC			(_COMM_PAGE_START_ADDRESS+0x5f0)	/* bit test-and-clear */
+ 
+#define _COMM_PAGE_BZERO		(_COMM_PAGE_START_ADDRESS+0x600)	/* bzero() */
+#define _COMM_PAGE_BCOPY		(_COMM_PAGE_START_ADDRESS+0x780)	/* bcopy() */
+#define	_COMM_PAGE_MEMCPY		(_COMM_PAGE_START_ADDRESS+0x7a0)	/* memcpy() */
+#define	_COMM_PAGE_MEMMOVE		(_COMM_PAGE_START_ADDRESS+0x7a0)	/* memmove() */
+#define	_COMM_PAGE_BCOPY_END		(_COMM_PAGE_START_ADDRESS+0xfff)	/* used by rosetta */
+
+#define	_COMM_PAGE_MEMSET_PATTERN       (_COMM_PAGE_START_ADDRESS+0x1000)	/* used by nonzero memset() */
+#define	_COMM_PAGE_LONGCOPY		(_COMM_PAGE_START_ADDRESS+0x1200)	/* used by bcopy() for very long operands */
+#define	_COMM_PAGE_LONGCOPY_END		(_COMM_PAGE_START_ADDRESS+0x15ff)	/* used by rosetta */
+
+#define _COMM_PAGE_BACKOFF		(_COMM_PAGE_START_ADDRESS+0x1600)	/* called from PFZ */
+#define _COMM_PAGE_FIFO_ENQUEUE		(_COMM_PAGE_START_ADDRESS+0x1680)	/* FIFO enqueue */
+#define _COMM_PAGE_FIFO_DEQUEUE		(_COMM_PAGE_START_ADDRESS+0x16c0)	/* FIFO dequeue */
+#define	_COMM_PAGE_NANOTIME		(_COMM_PAGE_START_ADDRESS+0x1700)	/* nanotime() */
+#define	_COMM_PAGE_MUTEX_LOCK		(_COMM_PAGE_START_ADDRESS+0x1780)	/* pthread_mutex_lock() */
+
+#define	_COMM_PAGE_UNUSED5		(_COMM_PAGE_START_ADDRESS+0x17e0)	/* unused space for regular code up to 0x1c00 */
+
+#define _COMM_PAGE_PFZ_START		(_COMM_PAGE_START_ADDRESS+0x1c00)	/* start of Preemption Free Zone */
+
+#define _COMM_PAGE_PFZ_ENQUEUE		(_COMM_PAGE_START_ADDRESS+0x1c00)	/* internal routine for FIFO enqueue */
+#define _COMM_PAGE_PFZ_DEQUEUE		(_COMM_PAGE_START_ADDRESS+0x1c80)	/* internal routine for FIFO dequeue */
+#define	_COMM_PAGE_PFZ_MUTEX_LOCK	(_COMM_PAGE_START_ADDRESS+0x1d00)	/* internal routine for pthread_mutex_lock() */
+
+#define	_COMM_PAGE_UNUSED6		(_COMM_PAGE_START_ADDRESS+0x1d80)	/* unused space for PFZ code up to 0x1fff */
+
+#define _COMM_PAGE_PFZ_END		(_COMM_PAGE_START_ADDRESS+0x1fff)	/* end of Preemption Free Zone */
+
+#define _COMM_PAGE_END			(_COMM_PAGE_START_ADDRESS+0x1fff)	/* end of common page - insert new stuff here */
+
+/* _COMM_PAGE_COMPARE_AND_SWAP{32,64}B are not used on x86 and are
+ * maintained here for source compatability.  These will be removed at
+ * some point, so don't go relying on them. */
+#define _COMM_PAGE_COMPARE_AND_SWAP32B  (_COMM_PAGE_START_ADDRESS+0xf80)	/* compare-and-swap word w barrier */
+#define _COMM_PAGE_COMPARE_AND_SWAP64B  (_COMM_PAGE_START_ADDRESS+0xfc0)	/* compare-and-swap doubleword w barrier */
+
+#ifdef __ASSEMBLER__
+#ifdef __COMM_PAGE_SYMBOLS
+
+#define CREATE_COMM_PAGE_SYMBOL(symbol_name, symbol_address)		\
+				.org	(symbol_address - (_COMM_PAGE_START_ADDRESS & 0xFFFFE000)) ;\
+symbol_name: nop
+
+	.text		/* Required to make a well behaved symbol file */
+
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap32, _COMM_PAGE_COMPARE_AND_SWAP32)
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap64, _COMM_PAGE_COMPARE_AND_SWAP64)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_enqueue, _COMM_PAGE_ENQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_dequeue, _COMM_PAGE_DEQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___memory_barrier, _COMM_PAGE_MEMORY_BARRIER)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_add32, _COMM_PAGE_ATOMIC_ADD32)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_add64, _COMM_PAGE_ATOMIC_ADD64)
+	CREATE_COMM_PAGE_SYMBOL(___cpu_number, _COMM_PAGE_CPU_NUMBER)
+	CREATE_COMM_PAGE_SYMBOL(___mach_absolute_time, _COMM_PAGE_ABSOLUTE_TIME)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock_try, _COMM_PAGE_SPINLOCK_TRY)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock, _COMM_PAGE_SPINLOCK_LOCK)
+	CREATE_COMM_PAGE_SYMBOL(___spin_unlock, _COMM_PAGE_SPINLOCK_UNLOCK)
+	CREATE_COMM_PAGE_SYMBOL(___pthread_getspecific, _COMM_PAGE_PTHREAD_GETSPECIFIC)
+	CREATE_COMM_PAGE_SYMBOL(___gettimeofday, _COMM_PAGE_GETTIMEOFDAY)
+	CREATE_COMM_PAGE_SYMBOL(___sys_dcache_flush, _COMM_PAGE_FLUSH_DCACHE)
+	CREATE_COMM_PAGE_SYMBOL(___sys_icache_invalidate, _COMM_PAGE_FLUSH_ICACHE)
+	CREATE_COMM_PAGE_SYMBOL(___pthread_self, _COMM_PAGE_PTHREAD_SELF)
+	CREATE_COMM_PAGE_SYMBOL(___pfz_preempt, _COMM_PAGE_PREEMPT)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock_relinquish, _COMM_PAGE_RELINQUISH)
+	CREATE_COMM_PAGE_SYMBOL(___bit_test_and_set, _COMM_PAGE_BTS)
+	CREATE_COMM_PAGE_SYMBOL(___bit_test_and_clear, _COMM_PAGE_BTC)
+	CREATE_COMM_PAGE_SYMBOL(___bzero, _COMM_PAGE_BZERO)
+	CREATE_COMM_PAGE_SYMBOL(___bcopy, _COMM_PAGE_BCOPY)
+	CREATE_COMM_PAGE_SYMBOL(___memcpy, _COMM_PAGE_MEMCPY)
+/*	CREATE_COMM_PAGE_SYMBOL(___memmove, _COMM_PAGE_MEMMOVE) */
+	CREATE_COMM_PAGE_SYMBOL(___memset_pattern, _COMM_PAGE_MEMSET_PATTERN)
+	CREATE_COMM_PAGE_SYMBOL(___longcopy, _COMM_PAGE_LONGCOPY)
+	CREATE_COMM_PAGE_SYMBOL(___backoff, _COMM_PAGE_BACKOFF)
+	CREATE_COMM_PAGE_SYMBOL(___fifo_enqueue, _COMM_PAGE_FIFO_ENQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___fifo_dequeue, _COMM_PAGE_FIFO_DEQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___nanotime, _COMM_PAGE_NANOTIME)
+	CREATE_COMM_PAGE_SYMBOL(___mutex_lock, _COMM_PAGE_MUTEX_LOCK)
+	CREATE_COMM_PAGE_SYMBOL(___pfz_enqueue, _COMM_PAGE_PFZ_ENQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___pfz_dequeue, _COMM_PAGE_PFZ_DEQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___pfz_mutex_lock, _COMM_PAGE_PFZ_MUTEX_LOCK)
+	CREATE_COMM_PAGE_SYMBOL(___end_comm_page, _COMM_PAGE_END)
+
+	.data		/* Required to make a well behaved symbol file */
+	.long	0	/* Required to make a well behaved symbol file */
+
+#endif /* __COMM_PAGE_SYMBOLS */
+#endif /* __ASSEMBLER__ */
+
+#endif /* _I386_CPU_CAPABILITIES_H */
+#endif /* PRIVATE */
diff --git a/include/System/machine/cpu_capabilities.h b/include/System/machine/cpu_capabilities.h
new file mode 100755
index 0000000..606ec28
--- /dev/null
+++ b/include/System/machine/cpu_capabilities.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	PRIVATE
+
+#ifndef _MACHINE_CPU_CAPABILITIES_H
+#define _MACHINE_CPU_CAPABILITIES_H
+
+#ifdef KERNEL_PRIVATE
+#if defined (__ppc__)
+#include "ppc/cpu_capabilities.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/cpu_capabilities.h"
+#else
+#error architecture not supported
+#endif
+
+#else /* !KERNEL_PRIVATE -- System Framework header */
+#if defined (__ppc__) || defined(__ppc64__)
+#include <System/ppc/cpu_capabilities.h>
+#elif defined (__i386__) || defined(__x86_64__)
+#include <System/i386/cpu_capabilities.h>
+#else
+#error architecture not supported
+#endif
+#endif /* KERNEL_PRIVATE */
+
+#endif /* _MACHINE_CPU_CAPABILITIES_H */
+#endif /* PRIVATE */
diff --git a/include/System/ppc/cpu_capabilities.h b/include/System/ppc/cpu_capabilities.h
new file mode 100755
index 0000000..268666c
--- /dev/null
+++ b/include/System/ppc/cpu_capabilities.h
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2003-2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	PRIVATE
+
+#ifndef _PPC_CPU_CAPABILITIES_H
+#define _PPC_CPU_CAPABILITIES_H
+
+/* _cpu_capabilities
+ *
+ * This is the authoritative way to determine from user mode what
+ * implementation-specific processor features are available.
+ * This API is only supported for Apple internal use.
+ */
+
+#ifndef	__ASSEMBLER__
+ 
+extern int _cpu_capabilities;
+ 
+#endif /* __ASSEMBLER__ */
+
+/* Bit definitions for _cpu_capabilities: */
+
+#define	kHasAltivec				0x00000001
+#define	k64Bit					0x00000002	// 64-bit GPRs
+#define	kCache32				0x00000004	// cache line size is 32 bytes
+#define	kCache64				0x00000008
+#define	kCache128				0x00000010
+#define	kDcbaRecommended		0x00000020	// PPC: dcba is available and recommended
+#define	kDcbaAvailable			0x00000040	// PPC: dcba is available (but may or may not be recommended)
+#define	kDataStreamsRecommended	0x00000080	// PPC: dst, dstt, dstst, dss, and dssall instructions available and recommended
+#define	kDataStreamsAvailable	0x00000100	// PPC: dst, dstt, dstst, dss, and dssall instructions available (may or may not be rec'd)
+#define	kDcbtStreamsRecommended	0x00000200	// PPC: enhanced dcbt instruction available and recommended
+#define	kDcbtStreamsAvailable	0x00000400	// PPC: enhanced dcbt instruction available (but may or may not be recommended)
+#define	kFastThreadLocalStorage	0x00000800	// TLS ptr is kept in a user-mode-readable register
+
+#define	kUP						0x00008000	// set if (kNumCPUs == 1)
+#define	kNumCPUs				0x00FF0000	// number of CPUs (see _NumCPUs() below)
+
+#define	kNumCPUsShift			16			// see _NumCPUs() below
+
+#define	kHasGraphicsOps			0x08000000	// PPC: has fres, frsqrte, and fsel instructions
+#define	kHasStfiwx				0x10000000	// PPC: has stfiwx instruction
+#define	kHasFsqrt				0x20000000	// PPC: has fsqrt and fsqrts instructions
+
+#ifndef	__ASSEMBLER__
+ 
+static __inline__ int _NumCPUs( void ) { return (_cpu_capabilities & kNumCPUs) >> kNumCPUsShift; }
+
+#endif /* __ASSEMBLER__ */
+
+
+/*
+ * The shared kernel/user "comm page(s)":
+ *
+ * The last eight pages of every address space are reserved for the kernel/user
+ * "comm area".  Because they can be addressed via a sign-extended 16-bit field,
+ * it is particularly efficient to access code or data in the comm area with
+ * absolute branches (ba, bla, bca) or absolute load/stores ("lwz r0,-4096(0)").
+ * Because the comm area can be reached from anywhere, dyld is not needed.
+ * Although eight pages are reserved, presently only two are populated and mapped.
+ *
+ * Routines on the comm page(s) can be thought of as the firmware for extended processor
+ * instructions, whose opcodes are special forms of "bla".  Ie, they are cpu
+ * capabilities.  During system initialization, the kernel populates the comm page with
+ * code customized for the particular processor and platform.
+ *
+ * Because Mach VM cannot map the last page of an address space, the max length of
+ * the comm area is seven pages.
+ */
+ 
+#define _COMM_PAGE_BASE_ADDRESS			(-8*4096)						// start at page -8, ie 0xFFFF8000
+#define	_COMM_PAGE_AREA_LENGTH			( 7*4096)						// reserved length of entire comm area
+#define	_COMM_PAGE_AREA_USED			( 2*4096)						// we use two pages so far
+
+/* The following set of definitions are used in the kernel, which needs to distinguish between
+ * the 32 and 64-bit commpage addresses and lengths.  On PPC they are the same, but on Imtel
+ * they are not.
+ */
+#define _COMM_PAGE32_BASE_ADDRESS		( _COMM_PAGE_BASE_ADDRESS )
+#define _COMM_PAGE64_BASE_ADDRESS		( _COMM_PAGE_BASE_ADDRESS )
+#define	_COMM_PAGE32_AREA_LENGTH		( _COMM_PAGE_AREA_LENGTH )
+#define	_COMM_PAGE64_AREA_LENGTH		( _COMM_PAGE_AREA_LENGTH )
+#define	_COMM_PAGE32_AREA_USED			( _COMM_PAGE_AREA_USED )
+#define	_COMM_PAGE64_AREA_USED			( _COMM_PAGE_AREA_USED )
+
+/* The Objective-C runtime fixed address page to optimize message dispatch */
+#define _OBJC_PAGE_BASE_ADDRESS			(-20*4096)						// start at page -20, ie 0xFFFEC000
+ 
+/*
+ * Objective-C needs an "absolute" area all the way up to the top of the
+ * address space.
+ * For a ppc32 task, that area gets allocated at runtime from user space.
+ * For a ppc64 task, that area is not within the user-accessible address range,
+ * so we pre-allocate it at exec time (see vm_map_exec()) along with the
+ * comm page.
+ * 
+ * NOTE: that means we can't "nest" the 64-bit comm page...
+ */
+#define _COMM_PAGE32_OBJC_SIZE	0ULL
+#define _COMM_PAGE32_OBJC_BASE	0ULL
+#if 0
+#define _COMM_PAGE64_OBJC_SIZE	(4 * 4096)
+#define _COMM_PAGE64_OBJC_BASE	(_OBJC_PAGE_BASE_ADDRESS)
+#else
+/*
+ * PPC51: ppc64 is limited to 51-bit addresses.
+ * PPC64 has a 51-bit address space limit, so we can't just go and
+ * map the Obj-C area up there.  We would have to create a nested pmap
+ * and make a special mapping that redirects the large virtual addresses to
+ * that other address space with lower addresses that fit within the 51-bit
+ * limit.
+ * VM would then have to handle this redirection when we fault one
+ * of these pages in but it doesn't do that at this point, so no
+ * Obj-C area for ppc64 for now :-(
+ */
+#define _COMM_PAGE64_OBJC_SIZE	0ULL
+#define _COMM_PAGE64_OBJC_BASE	0ULL
+#endif
+
+/* data in the comm page */
+ 
+#define _COMM_PAGE_SIGNATURE			(_COMM_PAGE_BASE_ADDRESS+0x000)	// first few bytes are a signature
+#define _COMM_PAGE_VERSION				(_COMM_PAGE_BASE_ADDRESS+0x01E)	// 16-bit version#
+#define	_COMM_PAGE_THIS_VERSION			2								// this is version 2 of the commarea format
+  
+#define _COMM_PAGE_CPU_CAPABILITIES		(_COMM_PAGE_BASE_ADDRESS+0x020)	// mirror of extern int _cpu_capabilities
+#define _COMM_PAGE_NCPUS				(_COMM_PAGE_BASE_ADDRESS+0x021)	// number of configured CPUs
+#define _COMM_PAGE_ALTIVEC				(_COMM_PAGE_BASE_ADDRESS+0x024)	// nonzero if Altivec available
+#define _COMM_PAGE_64_BIT				(_COMM_PAGE_BASE_ADDRESS+0x025)	// nonzero if 64-bit processor
+#define _COMM_PAGE_CACHE_LINESIZE		(_COMM_PAGE_BASE_ADDRESS+0x026)	// cache line size (16-bit field)
+ 
+#define _COMM_PAGE_UNUSED1				(_COMM_PAGE_BASE_ADDRESS+0x028)	// 24 unused bytes
+ 
+#define _COMM_PAGE_2_TO_52				(_COMM_PAGE_BASE_ADDRESS+0x040)	// double float constant 2**52
+#define _COMM_PAGE_10_TO_6				(_COMM_PAGE_BASE_ADDRESS+0x048)	// double float constant 10**6
+#define _COMM_PAGE_MAGIC_FE             (_COMM_PAGE_BASE_ADDRESS+0x050) // magic constant 0xFEFEFEFEFEFEFEFF (to find 0s)
+#define _COMM_PAGE_MAGIC_80             (_COMM_PAGE_BASE_ADDRESS+0x058) // magic constant 0x8080808080808080 (to find 0s)
+ 
+#define _COMM_PAGE_TIMEBASE				(_COMM_PAGE_BASE_ADDRESS+0x060)	// used by gettimeofday()
+#define _COMM_PAGE_TIMESTAMP			(_COMM_PAGE_BASE_ADDRESS+0x068)	// used by gettimeofday()
+#define _COMM_PAGE_SEC_PER_TICK			(_COMM_PAGE_BASE_ADDRESS+0x070)	// used by gettimeofday()
+ 
+ /* jump table (bla to this address, which may be a branch to the actual code somewhere else) */
+ /* When new jump table entries are added, corresponding symbols should be added below         */
+ 
+#define _COMM_PAGE_COMPARE_AND_SWAP32   (_COMM_PAGE_BASE_ADDRESS+0x080) // compare-and-swap word, no barrier
+#define _COMM_PAGE_COMPARE_AND_SWAP64   (_COMM_PAGE_BASE_ADDRESS+0x0c0) // compare-and-swap doubleword, no barrier
+#define _COMM_PAGE_ENQUEUE				(_COMM_PAGE_BASE_ADDRESS+0x100) // enqueue
+#define _COMM_PAGE_DEQUEUE				(_COMM_PAGE_BASE_ADDRESS+0x140) // dequeue
+#define _COMM_PAGE_MEMORY_BARRIER		(_COMM_PAGE_BASE_ADDRESS+0x180) // memory barrier
+#define _COMM_PAGE_ATOMIC_ADD32			(_COMM_PAGE_BASE_ADDRESS+0x1a0) // add atomic word
+#define _COMM_PAGE_ATOMIC_ADD64			(_COMM_PAGE_BASE_ADDRESS+0x1c0) // add atomic doubleword
+
+#define _COMM_PAGE_UNUSED3				(_COMM_PAGE_BASE_ADDRESS+0x1e0) // 32 unused bytes
+
+#define _COMM_PAGE_ABSOLUTE_TIME		(_COMM_PAGE_BASE_ADDRESS+0x200)	// mach_absolute_time()
+#define _COMM_PAGE_SPINLOCK_TRY			(_COMM_PAGE_BASE_ADDRESS+0x220)	// spinlock_try()
+#define _COMM_PAGE_SPINLOCK_LOCK		(_COMM_PAGE_BASE_ADDRESS+0x260)	// spinlock_lock()
+#define _COMM_PAGE_SPINLOCK_UNLOCK		(_COMM_PAGE_BASE_ADDRESS+0x2a0)	// spinlock_unlock()
+#define _COMM_PAGE_PTHREAD_GETSPECIFIC	(_COMM_PAGE_BASE_ADDRESS+0x2c0)	// pthread_getspecific()
+#define _COMM_PAGE_GETTIMEOFDAY			(_COMM_PAGE_BASE_ADDRESS+0x2e0)	// used by gettimeofday()
+#define _COMM_PAGE_FLUSH_DCACHE			(_COMM_PAGE_BASE_ADDRESS+0x4e0)	// sys_dcache_flush()
+#define _COMM_PAGE_FLUSH_ICACHE			(_COMM_PAGE_BASE_ADDRESS+0x520)	// sys_icache_invalidate()
+#define _COMM_PAGE_PTHREAD_SELF			(_COMM_PAGE_BASE_ADDRESS+0x580)	// pthread_self()
+
+#define	_COMM_PAGE_UNUSED4				(_COMM_PAGE_BASE_ADDRESS+0x5a0)	// 32 unused bytes
+
+#define	_COMM_PAGE_RELINQUISH			(_COMM_PAGE_BASE_ADDRESS+0x5c0)	// used by spinlocks
+ 
+#define _COMM_PAGE_UNUSED5				(_COMM_PAGE_BASE_ADDRESS+0x5e0)	// 32 unused bytes
+ 
+#define _COMM_PAGE_BZERO				(_COMM_PAGE_BASE_ADDRESS+0x600)	// bzero()
+#define _COMM_PAGE_BCOPY				(_COMM_PAGE_BASE_ADDRESS+0x780)	// bcopy()
+#define	_COMM_PAGE_MEMCPY				(_COMM_PAGE_BASE_ADDRESS+0x7a0)	// memcpy()
+#define	_COMM_PAGE_MEMMOVE				(_COMM_PAGE_BASE_ADDRESS+0x7a0)	// memmove()
+
+#define _COMM_PAGE_COMPARE_AND_SWAP32B  (_COMM_PAGE_BASE_ADDRESS+0xf80)	// compare-and-swap word w barrier
+#define _COMM_PAGE_COMPARE_AND_SWAP64B  (_COMM_PAGE_BASE_ADDRESS+0xfc0)	// compare-and-swap doubleword w barrier
+
+#define	_COMM_PAGE_MEMSET_PATTERN       (_COMM_PAGE_BASE_ADDRESS+0x1000)// used by nonzero memset()
+#define	_COMM_PAGE_BIGCOPY				(_COMM_PAGE_BASE_ADDRESS+0x1140)// very-long-operand copies
+
+#define _COMM_PAGE_END					(_COMM_PAGE_BASE_ADDRESS+0x1700)// end of commpage area
+
+#ifdef __ASSEMBLER__
+#ifdef __COMM_PAGE_SYMBOLS
+
+#define CREATE_COMM_PAGE_SYMBOL(symbol_name, symbol_address)		\
+				.org	(symbol_address - _COMM_PAGE_BASE_ADDRESS) @\
+symbol_name: nop
+
+	.text		// Required to make a well behaved symbol file
+
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap32, _COMM_PAGE_COMPARE_AND_SWAP32)
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap64, _COMM_PAGE_COMPARE_AND_SWAP64)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_enqueue, _COMM_PAGE_ENQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_dequeue, _COMM_PAGE_DEQUEUE)
+	CREATE_COMM_PAGE_SYMBOL(___memory_barrier, _COMM_PAGE_MEMORY_BARRIER)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_add32, _COMM_PAGE_ATOMIC_ADD32)
+	CREATE_COMM_PAGE_SYMBOL(___atomic_add64, _COMM_PAGE_ATOMIC_ADD64)
+	CREATE_COMM_PAGE_SYMBOL(___mach_absolute_time, _COMM_PAGE_ABSOLUTE_TIME)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock_try, _COMM_PAGE_SPINLOCK_TRY)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock, _COMM_PAGE_SPINLOCK_LOCK)
+	CREATE_COMM_PAGE_SYMBOL(___spin_unlock, _COMM_PAGE_SPINLOCK_UNLOCK)
+	CREATE_COMM_PAGE_SYMBOL(___pthread_getspecific, _COMM_PAGE_PTHREAD_GETSPECIFIC)
+	CREATE_COMM_PAGE_SYMBOL(___gettimeofday, _COMM_PAGE_GETTIMEOFDAY)
+	CREATE_COMM_PAGE_SYMBOL(___sys_dcache_flush, _COMM_PAGE_FLUSH_DCACHE)
+	CREATE_COMM_PAGE_SYMBOL(___sys_icache_invalidate, _COMM_PAGE_FLUSH_ICACHE)
+	CREATE_COMM_PAGE_SYMBOL(___pthread_self, _COMM_PAGE_PTHREAD_SELF)
+	CREATE_COMM_PAGE_SYMBOL(___spin_lock_relinquish, _COMM_PAGE_RELINQUISH)
+	CREATE_COMM_PAGE_SYMBOL(___bzero, _COMM_PAGE_BZERO)
+	CREATE_COMM_PAGE_SYMBOL(___bcopy, _COMM_PAGE_BCOPY)
+	CREATE_COMM_PAGE_SYMBOL(___memcpy, _COMM_PAGE_MEMCPY)
+//	CREATE_COMM_PAGE_SYMBOL(___memmove, _COMM_PAGE_MEMMOVE)
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap32b, _COMM_PAGE_COMPARE_AND_SWAP32B)
+	CREATE_COMM_PAGE_SYMBOL(___compare_and_swap64b, _COMM_PAGE_COMPARE_AND_SWAP64B)
+    CREATE_COMM_PAGE_SYMBOL(___memset_pattern, _COMM_PAGE_MEMSET_PATTERN)
+	CREATE_COMM_PAGE_SYMBOL(___bigcopy, _COMM_PAGE_BIGCOPY)
+	
+	CREATE_COMM_PAGE_SYMBOL(___end_comm_page, _COMM_PAGE_END)
+
+	.data		// Required to make a well behaved symbol file
+	.long	0	// Required to make a well behaved symbol file
+
+#endif /* __COMM_PAGE_SYMBOLS */
+#endif /* __ASSEMBLER__ */
+
+#endif /* _PPC_CPU_CAPABILITIES_H */
+#endif /* PRIVATE */
diff --git a/include/System/pthread_machdep.h b/include/System/pthread_machdep.h
new file mode 100755
index 0000000..951675d
--- /dev/null
+++ b/include/System/pthread_machdep.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (c) 2003-2004, 2008, 2011 Apple Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+ * Copyright 1996 1995 by Open Software Foundation, Inc. 1997 1996 1995 1994 1993 1992 1991
+ *              All Rights Reserved
+ *
+ * Permission to use, copy, modify, and distribute this software and
+ * its documentation for any purpose and without fee is hereby granted,
+ * provided that the above copyright notice appears in all copies and
+ * that both the copyright notice and this permission notice appear in
+ * supporting documentation.
+ *
+ * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE.
+ *
+ * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
+ * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * MkLinux
+ */
+
+/* Machine-dependent definitions for pthread internals. */
+
+#ifndef _POSIX_PTHREAD_MACHDEP_H
+#define _POSIX_PTHREAD_MACHDEP_H
+
+#ifndef __ASSEMBLER__
+
+#include <System/machine/cpu_capabilities.h>
+#ifdef __arm__
+#include <arm/arch.h>
+#endif
+#include <TargetConditionals.h>
+#include <stdint.h>
+
+/*
+ ** Define macros for inline pthread_getspecific() usage.
+ ** We reserve a number of slots for Apple internal use.
+ ** This number can grow dynamically, no need to fix it.
+ */
+
+/* This header contains pre defined thread specific keys */
+/* 0 is used for pthread_self */
+#define _PTHREAD_TSD_SLOT_PTHREAD_SELF		0
+/* Keys 1- 9 for use by dyld, directly or indirectly */
+#define _PTHREAD_TSD_SLOT_DYLD_1		1
+#define _PTHREAD_TSD_SLOT_DYLD_2		2
+#define _PTHREAD_TSD_SLOT_DYLD_3		3
+#define _PTHREAD_TSD_RESERVED_SLOT_COUNT	4
+/* To mirror the usage by dyld for Unwind_SjLj */
+#define _PTHREAD_TSD_SLOT_DYLD_8		8
+
+/* Keys 10 - 29 are for Libc/Libsystem internal ussage */
+/* used as __pthread_tsd_first + Num  */
+#define __PTK_LIBC_LOCALE_KEY		10
+#define __PTK_LIBC_TTYNAME_KEY		11
+#define __PTK_LIBC_LOCALTIME_KEY	12
+#define __PTK_LIBC_GMTIME_KEY		13
+#define __PTK_LIBC_GDTOA_BIGINT_KEY	14
+#define __PTK_LIBC_PARSEFLOAT_KEY	15
+/* for usage by dyld */
+#define __PTK_LIBC_DYLD_Unwind_SjLj_Key	18
+
+/* Keys 20-25 for libdispactch usage */
+#define __PTK_LIBDISPATCH_KEY0		20
+#define __PTK_LIBDISPATCH_KEY1		21
+#define __PTK_LIBDISPATCH_KEY2		22
+#define __PTK_LIBDISPATCH_KEY3		23
+#define __PTK_LIBDISPATCH_KEY4		24
+#define __PTK_LIBDISPATCH_KEY5		25
+
+/* Keys 30-255 for Non Libsystem usage */
+
+/* Keys 30-39 for Graphic frameworks usage */
+#define _PTHREAD_TSD_SLOT_OPENGL	30	/* backwards compat sake */
+#define __PTK_FRAMEWORK_OPENGL_KEY	30
+#define __PTK_FRAMEWORK_GRAPHICS_KEY1	31
+#define __PTK_FRAMEWORK_GRAPHICS_KEY2	32
+#define __PTK_FRAMEWORK_GRAPHICS_KEY3	33
+#define __PTK_FRAMEWORK_GRAPHICS_KEY4	34
+#define __PTK_FRAMEWORK_GRAPHICS_KEY5	35
+#define __PTK_FRAMEWORK_GRAPHICS_KEY6	36
+#define __PTK_FRAMEWORK_GRAPHICS_KEY7	37
+#define __PTK_FRAMEWORK_GRAPHICS_KEY8	38
+#define __PTK_FRAMEWORK_GRAPHICS_KEY9	39
+
+/* Keys 40-49 for Objective-C runtime usage */
+#define __PTK_FRAMEWORK_OBJC_KEY0	40
+#define __PTK_FRAMEWORK_OBJC_KEY1	41
+#define __PTK_FRAMEWORK_OBJC_KEY2	42
+#define __PTK_FRAMEWORK_OBJC_KEY3	43
+#define __PTK_FRAMEWORK_OBJC_KEY4	44
+#define __PTK_FRAMEWORK_OBJC_KEY5	45
+#define __PTK_FRAMEWORK_OBJC_KEY6	46
+#define __PTK_FRAMEWORK_OBJC_KEY7	47
+#define __PTK_FRAMEWORK_OBJC_KEY8	48
+#define __PTK_FRAMEWORK_OBJC_KEY9	49
+
+/* Keys 50-59 for Core Foundation usage */
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY0	50
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY1	51
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY2	52
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY3	53
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY4	54
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY5	55
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY6	56
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY7	57
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY8	58
+#define __PTK_FRAMEWORK_COREFOUNDATION_KEY9	59
+
+/* Keys 60-69 for Foundation usage */
+#define __PTK_FRAMEWORK_FOUNDATION_KEY0		60
+#define __PTK_FRAMEWORK_FOUNDATION_KEY1		61
+#define __PTK_FRAMEWORK_FOUNDATION_KEY2		62
+#define __PTK_FRAMEWORK_FOUNDATION_KEY3		63
+#define __PTK_FRAMEWORK_FOUNDATION_KEY4		64
+#define __PTK_FRAMEWORK_FOUNDATION_KEY5		65
+#define __PTK_FRAMEWORK_FOUNDATION_KEY6		66
+#define __PTK_FRAMEWORK_FOUNDATION_KEY7		67
+#define __PTK_FRAMEWORK_FOUNDATION_KEY8		68
+#define __PTK_FRAMEWORK_FOUNDATION_KEY9		69
+
+/* Keys 70-79 for Core Animation/QuartzCore usage */
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY0		70
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY1		71
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY2		72
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY3		73
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY4		74
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY5		75
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY6		76
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY7		77
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY8		78
+#define __PTK_FRAMEWORK_QUARTZCORE_KEY9		79
+
+
+/* Keys 80-89 for Garbage Collection */
+#define __PTK_FRAMEWORK_OLDGC_KEY0		80
+#define __PTK_FRAMEWORK_OLDGC_KEY1		81
+#define __PTK_FRAMEWORK_OLDGC_KEY2		82
+#define __PTK_FRAMEWORK_OLDGC_KEY3		83
+#define __PTK_FRAMEWORK_OLDGC_KEY4		84
+#define __PTK_FRAMEWORK_OLDGC_KEY5		85
+#define __PTK_FRAMEWORK_OLDGC_KEY6		86
+#define __PTK_FRAMEWORK_OLDGC_KEY7		87
+#define __PTK_FRAMEWORK_OLDGC_KEY8		88
+#define __PTK_FRAMEWORK_OLDGC_KEY9		89
+
+/* Keys 90-94 for JavaScriptCore Collection */
+#define __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY0		90
+#define __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY1		91
+#define __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY2		92
+#define __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY3		93
+#define __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY4		94
+/* Keys 95 for CoreText */
+#define __PTK_FRAMEWORK_CORETEXT_KEY0			95
+
+/* Keys 110-119 for Garbage Collection */
+#define __PTK_FRAMEWORK_GC_KEY0		110
+#define __PTK_FRAMEWORK_GC_KEY1		111
+#define __PTK_FRAMEWORK_GC_KEY2		112
+#define __PTK_FRAMEWORK_GC_KEY3		113
+#define __PTK_FRAMEWORK_GC_KEY4		114
+#define __PTK_FRAMEWORK_GC_KEY5		115
+#define __PTK_FRAMEWORK_GC_KEY6		116
+#define __PTK_FRAMEWORK_GC_KEY7		117
+#define __PTK_FRAMEWORK_GC_KEY8		118
+#define __PTK_FRAMEWORK_GC_KEY9		119
+
+/*
+ ** Define macros for inline pthread_getspecific() usage.
+ ** We reserve a number of slots for Apple internal use.
+ ** This number can grow dynamically, no need to fix it.
+ */
+
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+    
+    extern void *pthread_getspecific(unsigned long);
+    extern int pthread_setspecific(unsigned long, const void *);
+    /* setup destructor function for static key as it is not created with pthread_key_create() */
+    int       pthread_key_init_np(int, void (*)(void *));
+    
+#if defined(__cplusplus)
+}
+#endif
+
+typedef int pthread_lock_t;
+
+__inline__ static int
+_pthread_has_direct_tsd(void)
+{
+#if TARGET_IPHONE_SIMULATOR
+	/* Simulator will use the host implementation, so bypass the macro that is in the target code */
+	return 0;
+#elif defined(__ppc__)
+	int *caps = (int *)_COMM_PAGE_CPU_CAPABILITIES;
+	if (*caps & kFastThreadLocalStorage) {
+		return 1;
+	} else {
+		return 0;
+	}
+#else
+	return 1;
+#endif
+}
+
+#if TARGET_IPHONE_SIMULATOR || defined(__ppc__) || defined(__ppc64__) || \
+(defined(__arm__) && !defined(_ARM_ARCH_7) && defined(_ARM_ARCH_6) && defined(__thumb__))
+
+#define _pthread_getspecific_direct(key) pthread_getspecific((key))
+#define _pthread_setspecific_direct(key, val) pthread_setspecific((key), (val))
+
+#else
+
+/* To be used with static constant keys only */
+__inline__ static void *
+_pthread_getspecific_direct(unsigned long slot)
+{
+	void *ret;
+#if defined(__i386__) || defined(__x86_64__)
+	__asm__("mov %%gs:%1, %0" : "=r" (ret) : "m" (*(void **)(slot * sizeof(void *))));
+#elif (defined(__arm__) && (defined(_ARM_ARCH_6) || defined(_ARM_ARCH_5)))
+	void **__pthread_tsd;
+#if defined(__arm__) && defined(_ARM_ARCH_6)
+	uintptr_t __pthread_tpid;
+	__asm__("mrc p15, 0, %0, c13, c0, 3" : "=r" (__pthread_tpid));
+	__pthread_tsd = (void**)(__pthread_tpid & ~0x3ul);
+#elif defined(__arm__) && defined(_ARM_ARCH_5)
+	register uintptr_t __pthread_tpid asm ("r9");
+	__pthread_tsd = (void**)__pthread_tpid;
+#endif
+	ret = __pthread_tsd[slot];
+#else
+#error no _pthread_getspecific_direct implementation for this arch
+#endif
+	return ret;
+}
+
+/* To be used with static constant keys only */
+__inline__ static int
+_pthread_setspecific_direct(unsigned long slot, void * val)
+{
+#if defined(__i386__)
+#if defined(__PIC__)
+	__asm__("movl %1,%%gs:%0" : "=m" (*(void **)(slot * sizeof(void *))) : "rn" (val));
+#else
+	__asm__("movl %1,%%gs:%0" : "=m" (*(void **)(slot * sizeof(void *))) : "ri" (val));
+#endif
+#elif defined(__x86_64__)
+	/* PIC is free and cannot be disabled, even with: gcc -mdynamic-no-pic ... */
+	__asm__("movq %1,%%gs:%0" : "=m" (*(void **)(slot * sizeof(void *))) : "rn" (val));
+#elif (defined(__arm__) && (defined(_ARM_ARCH_6) || defined(_ARM_ARCH_5)))
+	void **__pthread_tsd;
+#if defined(__arm__) && defined(_ARM_ARCH_6)
+	uintptr_t __pthread_tpid;
+	__asm__("mrc p15, 0, %0, c13, c0, 3" : "=r" (__pthread_tpid));
+	__pthread_tsd = (void**)(__pthread_tpid & ~0x3ul);
+#elif defined(__arm__) && defined(_ARM_ARCH_5)
+	register uintptr_t __pthread_tpid asm ("r9");
+	__pthread_tsd = (void**)__pthread_tpid;
+#endif
+	__pthread_tsd[slot] = val;
+#else
+#error no _pthread_setspecific_direct implementation for this arch
+#endif
+	return 0;
+}
+
+#endif
+
+#define LOCK_INIT(l)	((l) = 0)
+#define LOCK_INITIALIZER 0
+
+#endif /* ! __ASSEMBLER__ */
+#endif /* _POSIX_PTHREAD_MACHDEP_H */
\ No newline at end of file
diff --git a/include/_simple.h b/include/_simple.h
new file mode 100644
index 0000000..6ba2e52
--- /dev/null
+++ b/include/_simple.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2006, 2010 Apple Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_LICENSE_HEADER_END@
+ */
+#include <sys/cdefs.h>
+#include <stdarg.h>
+#include <asl.h>
+
+typedef void *_SIMPLE_STRING;
+typedef const char *_esc_func(unsigned char);
+
+__BEGIN_DECLS
+/*
+ * A simplified vfprintf variant.  The format string is interpreted with
+ * arguments from the va_list, and the results are written to the given
+ * file descriptor.
+ */
+void _simple_vdprintf(int __fd, const char *__fmt, va_list __ap);
+
+/*
+ * A simplified fprintf variant.  The format string is interpreted with
+ * arguments from the variable argument list, and the results are written
+ * to the given file descriptor.
+ */
+void _simple_dprintf(int __fd, const char *__fmt, ...);
+
+/*
+ * A simplified string allocate routine.  Pass the opaque pointer to structure
+ * to _simple_*sprintf() routines.  Use _simple_string() to retrieve the
+ * current string (the string is guaranteed to be null terminated only on
+ * the call to _simple_string()).  Use _simple_sfree() to free the structure
+ * and string memory.
+ */
+_SIMPLE_STRING _simple_salloc(void);
+
+/*
+ * The format string is interpreted with arguments from the va_list, and the
+ * results are appended to the string maintained by the opaque structure, as
+ * returned by a previous call to _simple_salloc().  Non-zero is returned on
+ * out-of-memory error.
+ */
+int _simple_vsprintf(_SIMPLE_STRING __b, const char *__fmt, va_list __ap);
+
+/*
+ * The format string is interpreted with arguments from the variable argument
+ * list, and the results are appended to the string maintained by the opaque
+ * structure, as returned by a previous call to _simple_salloc().  Non-zero is
+ * returned on out-of-memory error.
+ */
+int _simple_sprintf(_SIMPLE_STRING __b, const char *__fmt, ...);
+
+/*
+ * Like _simple_vsprintf(), except __esc is a function to call on each
+ * character; the function returns NULL if the character should be passed
+ * as is, otherwise, the returned character string is used instead.
+ */
+int _simple_vesprintf(_SIMPLE_STRING __b, _esc_func __esc, const char *__fmt, va_list __ap);
+
+/*
+ * Like _simple_sprintf(), except __esc is a function to call on each
+ * character; the function returns NULL if the character should be passed
+ * as is, otherwise, the returned character string is used instead.
+ */
+int _simple_esprintf(_SIMPLE_STRING __b, _esc_func __esc, const char *__fmt, ...);
+
+/*
+ * Return the null terminated string from the opaque structure, as returned
+ * by a previous call to _simple_salloc().
+ */
+char *_simple_string(_SIMPLE_STRING __b);
+
+/*
+ * Reposition the pointer to the first null in the buffer.  After a call to
+ * _simple_string, the buffer can be modified, and shrunk.
+ */
+void _simple_sresize(_SIMPLE_STRING __b);
+
+/*
+ * Append the null-terminated string to the string associated with the opaque
+ * structure.  Non-zero is returned on out-of-memory error.
+ */
+int _simple_sappend(_SIMPLE_STRING __b, const char *__str);
+
+/*
+ * Like _simple_sappend(), except __esc is a function to call on each
+ * character; the function returns NULL if the character should be passed
+ * as is, otherwise, the returned character string is used instead.
+ */
+int _simple_esappend(_SIMPLE_STRING __b, _esc_func __esc, const char *__str);
+
+/*
+ * Write the string associated with the opaque structure to the file descriptor.
+ */
+void _simple_put(_SIMPLE_STRING __b, int __fd);
+
+/*
+ * Write the string associated with the opaque structure and a trailing newline,
+ * to the file descriptor.
+ */
+void _simple_putline(_SIMPLE_STRING __b, int __fd);
+
+/*
+ * Free the opaque structure, and the associated string.
+ */
+void _simple_sfree(_SIMPLE_STRING __b);
+
+/*
+ * Simplified ASL log interface; does not use malloc.  Unfortunately, this
+ * requires knowledge of the format used by ASL.
+ */
+void _simple_asl_log(int __level, const char *__facility, const char *__message);
+void _simple_asl_log_prog(int level, const char *facility, const char *message, const char *progname);
+__END_DECLS
\ No newline at end of file
diff --git a/include/auto_zone.h b/include/auto_zone.h
new file mode 100755
index 0000000..54e1d6f
--- /dev/null
+++ b/include/auto_zone.h
@@ -0,0 +1,694 @@
+/*
+ * Copyright (c) 2011 Apple Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+/*
+    auto_zone.h
+    Automatic Garbage Collection.
+    Copyright (c) 2002-2011 Apple Inc. All rights reserved.
+ */
+
+#ifndef __AUTO_ZONE__
+#define __AUTO_ZONE__
+
+#include <stdint.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <malloc/malloc.h>
+#include <Availability.h>
+#include <AvailabilityMacros.h>
+#include <TargetConditionals.h>
+
+#include <dispatch/dispatch.h>
+
+#define AUTO_EXPORT extern __attribute__((visibility("default")))
+
+__BEGIN_DECLS
+
+typedef malloc_zone_t auto_zone_t;
+    // an auto zone carries a little more state but can be cast into a malloc_zone_t
+
+AUTO_EXPORT auto_zone_t *auto_zone_create(const char *name)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // create an garbage collected zone.  Can be (theoretically) done more than once.
+    // memory can be allocated by malloc_zone_malloc(result, size)
+    // by default, this memory must be malloc_zone_free(result, ptr) as well (or generic free())
+
+AUTO_EXPORT struct malloc_introspection_t auto_zone_introspection()
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // access the zone introspection functions independent of any particular auto zone instance.
+    // this is used by tools to be able to introspect a zone in another process.
+    // the introspection functions returned are required to do version checking on the zone.
+
+#define AUTO_RETAINED_BLOCK_TYPE 0x100  /* zone enumerator returns only blocks with nonzero retain count */
+
+/*********  External (Global) Use counting  ************/
+
+AUTO_EXPORT void auto_zone_retain(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT unsigned int auto_zone_release(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT unsigned int auto_zone_retain_count(auto_zone_t *zone, const void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // All pointer in the auto zone have an explicit retain count
+    // Objects will not be collected when the retain count is non-zero
+
+/*********  Object information  ************/
+
+AUTO_EXPORT const void *auto_zone_base_pointer(auto_zone_t *zone, const void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // return base of interior pointer  (or NULL).
+AUTO_EXPORT boolean_t auto_zone_is_valid_pointer(auto_zone_t *zone, const void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // is this a pointer to the base of an allocated block?
+AUTO_EXPORT size_t auto_zone_size(auto_zone_t *zone, const void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+/*********  Write-barrier   ************/
+
+AUTO_EXPORT boolean_t auto_zone_set_write_barrier(auto_zone_t *zone, const void *dest, const void *new_value)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // must be used when an object field/slot in the auto zone is set to another object in the auto zone
+    // returns true if the dest was a valid target whose write-barrier was set
+
+AUTO_EXPORT boolean_t auto_zone_atomicCompareAndSwap(auto_zone_t *zone, void *existingValue, void *newValue, void *volatile *location, boolean_t isGlobal, boolean_t issueBarrier)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // Atomically update a location with a new GC value.  These use OSAtomicCompareAndSwapPtr{Barrier} with appropriate write-barrier interlocking logic.
+
+AUTO_EXPORT boolean_t auto_zone_atomicCompareAndSwapPtr(auto_zone_t *zone, void *existingValue, void *newValue, void *volatile *location, boolean_t issueBarrier)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+    // Atomically update a location with a new GC value.  These use OSAtomicCompareAndSwapPtr{Barrier} with appropriate write-barrier interlocking logic.
+    // This version checks location, and if it points into global storage, registers a root.
+
+AUTO_EXPORT void *auto_zone_write_barrier_memmove(auto_zone_t *zone, void *dst, const void *src, size_t size)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // copy content from an arbitrary source area to an arbitrary destination area
+    // marking write barrier if necessary
+
+/*********  Read-barrier   ************/
+
+AUTO_EXPORT void *auto_zone_strong_read_barrier(auto_zone_t *zone, void **source)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+/*********  Statistics  ************/
+
+typedef uint64_t auto_date_t;
+
+typedef struct {
+    auto_date_t     total_duration;
+    auto_date_t     scan_duration;
+    auto_date_t     enlivening_duration;
+    auto_date_t     finalize_duration;
+    auto_date_t     reclaim_duration;
+} auto_collection_durations_t;
+
+typedef struct {
+    /* Memory usage */
+    malloc_statistics_t malloc_statistics;
+    /* GC stats */
+    // version 0
+    uint32_t            version;            // set to 1 before calling
+    /* When there is an array, 0 stands for full collection, 1 for generational */
+    size_t              num_collections[2];
+    boolean_t           last_collection_was_generational;
+    size_t              bytes_in_use_after_last_collection[2];
+    size_t              bytes_allocated_after_last_collection[2];
+    size_t              bytes_freed_during_last_collection[2];
+    // durations
+    auto_collection_durations_t total[2];   // running total of each field
+    auto_collection_durations_t last[2];    // most recent result
+    auto_collection_durations_t maximum[2]; // on a per item basis, the max.  Thus, total != scan + finalize ...
+    // version 1 additions
+    size_t              thread_collections_total;
+    size_t              thread_blocks_recovered_total;
+    size_t              thread_bytes_recovered_total;
+} auto_statistics_t;
+
+AUTO_EXPORT void auto_zone_statistics(auto_zone_t *zone, auto_statistics_t *stats)
+    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_5_0,__IPHONE_5_0);
+    // set version to 0
+
+/*********  Garbage Collection   ************/
+
+enum {
+    AUTO_COLLECT_RATIO_COLLECTION        = (0 << 0), // run generational or full depending on applying AUTO_COLLECTION_RATIO
+    AUTO_COLLECT_GENERATIONAL_COLLECTION = (1 << 0), // collect young objects. Internal only.
+    AUTO_COLLECT_FULL_COLLECTION         = (2 << 0), // collect entire heap. Internal only.
+    AUTO_COLLECT_EXHAUSTIVE_COLLECTION   = (3 << 0), // run full collections until object count stabilizes.
+    AUTO_COLLECT_SYNCHRONOUS             = (1 << 2), // block caller until scanning is finished.
+    AUTO_COLLECT_IF_NEEDED               = (1 << 3), // only collect if AUTO_COLLECTION_THRESHOLD exceeded.
+};
+typedef uint32_t auto_collection_mode_t;
+
+enum {
+    AUTO_LOG_COLLECTIONS = (1 << 1),        // log block statistics whenever a collection occurs
+    AUTO_LOG_TIMINGS = (1 << 2),            // log timing data whenever a collection occurs
+    AUTO_LOG_REGIONS = (1 << 4),            // log whenever a new region is allocated
+    AUTO_LOG_UNUSUAL = (1 << 5),            // log unusual circumstances
+    AUTO_LOG_WEAK = (1 << 6),               // log weak reference manipulation
+    AUTO_LOG_ALL = (~0u),
+    AUTO_LOG_NONE = 0
+};
+typedef uint32_t auto_log_mask_t;
+
+enum {
+    AUTO_HEAP_HOLES_SHRINKING       = 1,        // total size of holes is approaching zero
+    AUTO_HEAP_HOLES_EXHAUSTED       = 2,        // all holes exhausted, will use hitherto unused memory in "subzone"
+    AUTO_HEAP_SUBZONE_EXHAUSTED     = 3,        // will add subzone
+    AUTO_HEAP_REGION_EXHAUSTED      = 4,        // no more subzones available, need to add region
+    AUTO_HEAP_ARENA_EXHAUSTED       = 5,        // arena exhausted.  (64-bit only)
+};
+typedef uint32_t auto_heap_growth_info_t;
+
+typedef struct auto_zone_cursor *auto_zone_cursor_t;
+typedef void (*auto_zone_foreach_object_t) (auto_zone_cursor_t cursor, void (*op) (void *ptr, void *data), void* data);
+
+typedef struct {
+    uint32_t        version;                    // sizeof(auto_collection_control_t)
+    void            (*batch_invalidate) (auto_zone_t *zone, auto_zone_foreach_object_t foreach, auto_zone_cursor_t cursor, size_t cursor_size);
+        // After unreached objects are found, collector calls this routine with internal context.
+        // Typically, one enters a try block to call back into the collector with a function pointer to be used to
+        // invalidate each object.  This amortizes the cost of the try block as well as allows the collector to use
+        // efficient contexts.
+    void            (*resurrect) (auto_zone_t *zone, void *ptr);
+        // Objects on the garbage list may be assigned into live objects in an attempted resurrection.  This is not allowed.
+        // This function, if supplied, is called for these objects to turn them into zombies.  The zombies may well hold
+        // pointers to other objects on the garbage list.  No attempt is made to preserved these objects beyond this collection.
+    const unsigned char* (*layout_for_address)(auto_zone_t *zone, void *ptr);
+        // The collector assumes that the first word of every "object" is a class pointer.
+        // For each class pointer discovered this function is called to return a layout, or NULL
+        // if the object should be scanned conservatively.
+        // The layout format is nibble pairs {skipcount, scancount}  XXX
+    const unsigned char* (*weak_layout_for_address)(auto_zone_t *zone, void *ptr);
+        // called once for each allocation encountered for which we don't know the weak layout
+        // the callee returns a weak layout for the allocation or NULL if the allocation has no weak references.
+    char*           (*name_for_address) (auto_zone_t *zone, vm_address_t base, vm_address_t offset);
+        // if supplied, is used during logging for errors such as resurrections
+    auto_log_mask_t log;
+        // set to auto_log_mask_t bits as desired
+    boolean_t       disable_generational;
+        // if true, ignores requests to do generational GC.
+    boolean_t       malloc_stack_logging;
+        // if true, logs allocations for malloc stack logging.  Automatically set if MallocStackLogging{NoCompact} is set
+    void            (*scan_external_callout)(void *context, void (*scanner)(void *context, void *start, void *end)) DEPRECATED_ATTRIBUTE;
+        // no longer used
+        
+    void            (*will_grow)(auto_zone_t *zone, auto_heap_growth_info_t) DEPRECATED_ATTRIBUTE;
+        // no longer used
+    
+    size_t          collection_threshold;
+        // if_needed threshold: collector will initiate a collection after this number of bytes is allocated.
+    size_t          full_vs_gen_frequency;
+        // after full_vs_gen_frequency generational collections, a full collection will occur, if the if_needed threshold exceeded
+    const char*     (*name_for_object) (auto_zone_t *zone, void *object);
+        // provides a type name for an AUTO_OBJECT
+} auto_collection_control_t;
+
+AUTO_EXPORT auto_collection_control_t *auto_collection_parameters(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // FIXME: API is to get the control struct and slam it
+    // sets a parameter that decides when callback gets called
+
+AUTO_EXPORT void auto_collector_disable(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT void auto_collector_reenable(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+    // these two functions turn off/on the collector
+    // default is on
+    // use with great care.
+
+AUTO_EXPORT boolean_t auto_zone_is_enabled(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT boolean_t auto_zone_is_collecting(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+AUTO_EXPORT void auto_collect(auto_zone_t *zone, auto_collection_mode_t mode, void *collection_context) 
+    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_5_0,__IPHONE_5_0);
+    // deprecated, use auto_zone_collect() instead
+
+AUTO_EXPORT void auto_collect_multithreaded(auto_zone_t *zone)
+    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_5_0,__IPHONE_5_0);
+    // deprecated
+
+
+// Options to auto_zone_collect().
+enum {
+    /* 
+       Request a collection with no options. This produces an advisory collection request which 
+       allows the collector to choose what collection is performed (or none) based on its internal 
+       heuristics. This is generally the only option that should be used in production code. 
+       All other options are intended primarily to support debugging and unit tests and may change 
+       meaning without notice.
+     */
+    AUTO_ZONE_COLLECT_NO_OPTIONS = 0,
+    
+    // The low order nibble specifies a request for a global heap collection. 
+    // Note that the ordinal value is significant. Higher numbered collection modes can override lower numbered.
+    AUTO_ZONE_COLLECT_RATIO_COLLECTION          = 1, // requests either a generational or a full collection, based on memory use heuristics.
+    AUTO_ZONE_COLLECT_GENERATIONAL_COLLECTION   = 2, // requests a generational heap collection.
+    AUTO_ZONE_COLLECT_FULL_COLLECTION           = 3, // requests a full heap collection.
+    AUTO_ZONE_COLLECT_EXHAUSTIVE_COLLECTION     = 4, // requests an exhaustive heap collection.
+    
+    AUTO_ZONE_COLLECT_GLOBAL_MODE_MAX           = AUTO_ZONE_COLLECT_EXHAUSTIVE_COLLECTION, // the highest numbered global mode
+    AUTO_ZONE_COLLECT_GLOBAL_MODE_COUNT         = AUTO_ZONE_COLLECT_EXHAUSTIVE_COLLECTION+1, // the highest numbered global mode
+    AUTO_ZONE_COLLECT_GLOBAL_COLLECTION_MODE_MASK       = 0xf,
+    
+    
+    // These bits requests a local collections be performed on the calling thread. It is permitted to request both a local collection and a global collection, in which case both will be performed.
+    
+    AUTO_ZONE_COLLECT_LOCAL_COLLECTION           = (1<<8),  // perform a normal thread local collection
+    
+    AUTO_ZONE_COLLECT_COALESCE                   = (1<<15), // allows the request to be skipped if a collection is in progress
+};
+
+/*
+   auto_zone_collect() is the entry point to request a collection.
+
+   Normally AUTO_ZONE_COLLECT_NO_OPTIONS should be passed for options. This indicates the call is an advisory 
+   collection request and the collector is free to perform any action it deems fit (including none). This is 
+   the only option that should be used in shipping production code. The other options provide fine grained control of
+   the collector intended for debugging and unit tests. Misuse of these options can degrade performance. 
+ */
+typedef intptr_t auto_zone_options_t;
+AUTO_EXPORT void auto_zone_collect(auto_zone_t *zone, auto_zone_options_t options)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#ifdef __BLOCKS__
+AUTO_EXPORT void auto_zone_collect_and_notify(auto_zone_t *zone, auto_zone_options_t options, dispatch_queue_t callback_queue, dispatch_block_t completion_callback)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+/*
+    auto_zone_compact() is the entry point to request a stop-the-world compaction of the heap. This can only be called from binaries
+    which are marked by the linker (see <rdar://problem/7421695>) as supporting compaction. Currently there are no options to control
+    compaction, but you can pass a queue/block callback pair that will be invoked after compaction finishes.
+ */
+
+enum {
+    AUTO_ZONE_COMPACT_NO_OPTIONS = 0,
+    AUTO_ZONE_COMPACT_IF_IDLE = 1,          /* primes compaction to start after delay, if no dispatch threads intervene. */
+    AUTO_ZONE_COMPACT_ANALYZE = 2,          /* runs a compaction analysis to file specified by environment variable. */
+};
+
+typedef uintptr_t auto_zone_compact_options_t;
+
+#ifdef __BLOCKS__
+AUTO_EXPORT void auto_zone_compact(auto_zone_t *zone, auto_zone_compact_options_t options, dispatch_queue_t callback_queue, dispatch_block_t completion_callback)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+/*
+    Compaction is enabled by default. The client runtime should call auto_zone_disable_compaction() when it detects that code that
+    is incompatible with compaction has been loaded. This is safe to call immediately after auto_zone_create().
+ */
+AUTO_EXPORT void auto_zone_disable_compaction(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+/*
+   External resource tracking.
+ 
+   The garbage collector tracks use of collectable memory. But it may be necessary to trigger garbage collections
+   based on use of other resources not tracked by the garbage collector, such as file descriptors. The garbage
+   collector provides this interface to register other resources tracking systems so the collector can query
+   if collection is needed. The garbage collector will periodically call all registered should_collect() blocks
+   and if any of them return true a collection cycle will execute. (However, the collector stops querying
+   external resource trackers once it has determined that a collection is necessary. In many cases the collector
+   will collect due to memory use without querying any external resource trackers at all.)
+ 
+   Resource tracking implementations should take care to avoid running collections continuously based on high
+   resource use when no resources are recovered. One strategy is to track resources allocated since the last 
+   triggered collection instead of a total allocation count.
+ */
+
+/*
+   Register should_collect() as an external resource tracker. The string passed in description is used
+   as a descriptive name for the resource tracker. When an external resource tracker triggers a collection the
+   description string appears in the log if AUTO_LOG_COLLECTIONS is enabled. The description string is copied.
+ */
+#ifdef __BLOCKS__
+AUTO_EXPORT void auto_zone_register_resource_tracker(auto_zone_t *zone, const char *description, boolean_t (^should_collect)(void))
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+/*
+   Unregister a should_collect() block that was previously registered with auto_zone_register_resource_tracker().
+   The garbage collector will no longer query the resource tracker.
+ */
+AUTO_EXPORT void auto_zone_unregister_resource_tracker(auto_zone_t *zone, const char *description)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+
+/*
+   auto_zone_reap_all_local_blocks() will immediately finalize and reclaim all blocks which are thread local to the calling thread.
+   No scanning or other liveness analysis will be performed. This function can be called as an optimization in the very specific
+   case where it is known that the stack cannot be rooting any blocks, such as a pthread event loop. (Note that this cannot be called
+   from a thread created by NSThread.)
+ */
+AUTO_EXPORT void auto_zone_reap_all_local_blocks(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+// Block Memory Type Flags
+// =======================
+// Blocks of memory allocated by auto_zone_allocate_object() are broadly classified as scanned/unscanned
+// and object/non-object. When objects become garbage, they are finalized by calling the batch_invalidate() callback.
+// For scanned objects, the collector uses the layout_for_address callback, to obtain a layout map that describes which
+// pointer sized words should be scanned, and which should be ignored. Scanned objects may also contain weak references
+// which are created via auto_assign_weak_reference(). The weak_layout_for_address callback is used to automatically
+// unregister non-NULL weak references in weak_unregister_with_layout(). Finally, the pointers_only bit applies only for
+// scanned memory and indicates that all otherwise unspecified fields are pointers, the most interesting consequence is that
+// they can be relocated during compaction.
+//
+// These flags are represented by auto_memory_type_t. see the comments below for the legal flag combinations. Once allocated,
+// SPI is provided to change the bits in only proscribed ways; to turn off "object" treatment; to turn off scanning;
+// to turn on all-pointers.
+
+enum {
+    AUTO_TYPE_UNKNOWN =     -1,                                             // this is an error value
+    // memory type bits.
+    AUTO_UNSCANNED =        (1 << 0),
+    AUTO_OBJECT =           (1 << 1),
+    AUTO_POINTERS_ONLY =    (1 << 2),
+    // allowed combinations of flags.
+    AUTO_MEMORY_SCANNED = !AUTO_UNSCANNED,                                  // conservatively scanned memory
+    AUTO_MEMORY_UNSCANNED = AUTO_UNSCANNED,                                 // unscanned memory (bits)
+    AUTO_MEMORY_ALL_POINTERS = AUTO_POINTERS_ONLY,                          // scanned array of pointers
+    AUTO_MEMORY_ALL_WEAK_POINTERS = (AUTO_UNSCANNED | AUTO_POINTERS_ONLY),  // unscanned, weak array of pointers
+    AUTO_OBJECT_SCANNED = AUTO_OBJECT,                                      // object memory, exactly scanned with layout maps, conservatively scanned remainder, will be finalized
+    AUTO_OBJECT_UNSCANNED = AUTO_OBJECT | AUTO_UNSCANNED,                   // unscanned object memory, will be finalized
+    AUTO_OBJECT_ALL_POINTERS = AUTO_OBJECT | AUTO_POINTERS_ONLY             // object memory, exactly scanned with layout maps, all-pointers scanned remainder, will be finalized
+};
+typedef int32_t auto_memory_type_t;
+
+AUTO_EXPORT auto_memory_type_t auto_zone_get_layout_type(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+AUTO_EXPORT void* auto_zone_allocate_object(auto_zone_t *zone, size_t size, auto_memory_type_t type, boolean_t initial_refcount_to_one, boolean_t clear)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+/* Batch allocator. Returns number of blocks allocated, which may be 0. */
+/* All blocks have the given memory type and initial reference count, and all blocks are zeroed. */
+AUTO_EXPORT unsigned auto_zone_batch_allocate(auto_zone_t *zone, size_t size, auto_memory_type_t type, boolean_t initial_refcount_to_one, boolean_t clear, void **results, unsigned num_requested)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+// Create copy of AUTO_MEMORY object preserving "scanned" attribute
+// If not auto memory then create unscanned memory copy
+AUTO_EXPORT void *auto_zone_create_copy(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+
+AUTO_EXPORT void auto_zone_register_thread(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+AUTO_EXPORT void auto_zone_unregister_thread(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+AUTO_EXPORT void auto_zone_assert_thread_registered(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+AUTO_EXPORT void auto_zone_register_datasegment(auto_zone_t *zone, void *address, size_t size)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_unregister_datasegment(auto_zone_t *zone, void *address, size_t size)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+
+// Weak references
+
+// The collector maintains a weak reference system.
+// Essentially, locations in which references are stored are registered along with the reference itself.
+// The location should not be within scanned GC memory.
+// After a collection, before finalization, all registered locations are examined and any containing references to
+// newly discovered garbage will be "zeroed" and the registration cancelled.
+//
+// Reading values from locations must be done through the weak read function because there is a race with such
+// reads and the collector having just determined that that value read is in fact otherwise garbage.
+//
+// The address of a callback block may be supplied optionally.  If supplied, if the location is zeroed, the callback
+// block is queued to be called later with the arguments supplied in the callback block.  The same callback block both
+// can and should be used as an aggregation point.  A table of weak locations could supply each registration with the
+// same pointer to a callback block that will call that table if items are zerod.  The callbacks are made before
+// finalization.  Note that only thread-safe operations may be performed by this callback.
+//
+// It is important to cancel all registrations before deallocating the memory containing locations or callback blocks.
+// Cancellation is done by calling the registration function with a NULL "reference" parameter for that location.
+
+#if defined(AUTO_USE_NEW_WEAK_CALLBACK)
+typedef struct new_auto_weak_callback_block auto_weak_callback_block_t;
+#else
+typedef struct old_auto_weak_callback_block auto_weak_callback_block_t;
+#endif
+
+struct new_auto_weak_callback_block {
+    void    *isa;                                           // provides layout for exact scanning.
+    auto_weak_callback_block_t *next;                       // must be set to zero before first use.
+    void   (*callback_function)(void *__strong target);
+    void    *__strong target;
+};
+
+struct old_auto_weak_callback_block {
+    auto_weak_callback_block_t *next;                       // must be set to zero before first use.
+    void (*callback_function)(void *arg1, void *arg2);
+    void *arg1;
+    void *arg2;
+} DEPRECATED_ATTRIBUTE;
+
+AUTO_EXPORT void auto_assign_weak_reference(auto_zone_t *zone, const void *value, const void **location, auto_weak_callback_block_t *block)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+// Read a weak-reference, informing the collector that it is now strongly referenced.
+AUTO_EXPORT void* auto_read_weak_reference(auto_zone_t *zone, void **referrer)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+// Compaction notification
+
+// Registers an observer that gets called whenever pointers are updated (by compaction) inside a block.
+// This could be used to trigger rehashing a hash table. The implementation isn't particularly efficient.
+#ifdef __BLOCKS__
+AUTO_EXPORT void auto_zone_set_compaction_observer(auto_zone_t *zone, void *block, void (^observer) (void))
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+// Global references
+
+AUTO_EXPORT void auto_zone_add_root(auto_zone_t *zone, void *address_of_root_ptr, void *value)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_remove_root(auto_zone_t *zone, void *address_of_root_ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+AUTO_EXPORT void auto_zone_root_write_barrier(auto_zone_t *zone, void *address_of_possible_root_ptr, void *value)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+
+// Associative references.
+
+// This informs the collector that an object A wishes to associate one or more secondary objects with object A's lifetime.
+// This can be used to implement GC-safe associations that will neither cause uncollectable cycles, nor suffer the limitations
+// of weak references.
+
+AUTO_EXPORT void auto_zone_set_associative_ref(auto_zone_t *zone, void *object, void *key, void *value)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT void *auto_zone_get_associative_ref(auto_zone_t *zone, void *object,  void *key)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_erase_associative_refs(auto_zone_t *zone, void *object)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+AUTO_EXPORT size_t auto_zone_get_associative_hash(auto_zone_t *zone, void *object)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+// Enumerates all known object, value pairs associated with the key parameter. Calls the specified block while the
+// assocations table locks are held, therefore adding/removing assocations will likely crash.
+#ifdef __BLOCKS__
+AUTO_EXPORT void auto_zone_enumerate_associative_refs(auto_zone_t *zone, void *key, boolean_t (^block) (void *object, void *value))
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+// Collection Checking
+
+// Collection checking is a debugging tool by which developers can verify that blocks are collecting as expected.
+// When collection checking is enabled the program can report memory blocks to the collector
+// that are expected to collect soon using auto_zone_track_pointer().
+// The program can detect which of these blocks were not collected by calling auto_zone_enumerate_uncollected().
+// Pointers that survive more than a few collections can be investigated as leaks.
+// While collection checking is enabled collector performance is degraded and memory use is increased.
+// While most garbage objects are detected and collected in just one collection attempt, there are
+// cases where several collections are required to reclaim a memory block even though it has no references.
+// Note also that a conservative stack reference is never cleared by running more collections.
+
+// Enable/disable collection checking. An "enabled" counter is maintained, so calls should be paried if desired.
+// Disabling collection checking and causes all previously tracked blocks to be unregistered (no longer tracked).
+AUTO_EXPORT boolean_t auto_zone_enable_collection_checking(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_disable_collection_checking(auto_zone_t *zone)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+// Inform the collector that the pointer is expected to collect soon. pointer will subsequently be reported by 
+// auto_zone_enumerate_uncollected() until it is collected.
+// Note that pointer is still rooted on the stack in the scope where auto_zone_block_should_collect() is called.
+AUTO_EXPORT void auto_zone_track_pointer(auto_zone_t *zone, void *pointer)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+#ifdef __BLOCKS__
+typedef struct {
+    boolean_t is_object;
+    size_t survived_count;
+} auto_zone_collection_checking_info;
+
+// Typedef for a handler block used to report uncollected memory. The collector provides: 
+// pointer - the memory block in question, which was previously passed to auto_zone_track_pointer()
+// info - a pointer to a auto_zone_collection_checking_info struct containing:
+//    is_object - true if the block was allocated as an object, false if it is not an object
+//    survived_count - a minimum count of collections the block has survived (the actual count may be higher)
+typedef void (^auto_zone_collection_checking_callback_t)(void *pointer, auto_zone_collection_checking_info *info);
+
+// Enumerate the memory blocks that were previously passed to auto_zone_track_pointer(). 
+// Any which have not been collected are reported using the callback.
+// The callback may be NULL, in which case the uncollected blocks are simply logged.
+AUTO_EXPORT void auto_zone_enumerate_uncollected(auto_zone_t *zone, auto_zone_collection_checking_callback_t callback)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+#endif
+
+
+
+/***** SPI ******/
+    
+AUTO_EXPORT boolean_t auto_zone_is_finalized(auto_zone_t *zone, const void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_set_nofinalize(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_set_unscanned(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_set_scan_exactly(auto_zone_t *zone, void *ptr)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_clear_stack(auto_zone_t *zone, unsigned long options)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+// Reference count logging support for ObjectAlloc et. al.
+
+enum {
+    AUTO_RETAIN_EVENT = 14,
+    AUTO_RELEASE_EVENT = 15
+};
+AUTO_EXPORT void (*__auto_reference_logger)(uint32_t eventtype, void *ptr, uintptr_t data)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+
+// Reference tracing
+
+// referrer_base[referrer_offset]  ->  referent
+typedef struct 
+{
+    vm_address_t referent;
+    vm_address_t referrer_base;
+    intptr_t     referrer_offset;
+} auto_reference_t;
+
+typedef void (*auto_reference_recorder_t)(auto_zone_t *zone, void *ctx, 
+                                          auto_reference_t reference);
+
+AUTO_EXPORT void auto_enumerate_references(auto_zone_t *zone, void *referent, 
+                                      auto_reference_recorder_t callback, 
+                                      void *stack_bottom, void *ctx)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+
+AUTO_EXPORT void **auto_weak_find_first_referrer(auto_zone_t *zone, void **location, unsigned long count)
+    __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_5_0);
+
+
+/************ DEPRECATED ***********/
+    
+AUTO_EXPORT auto_zone_t *auto_zone(void) 
+    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_5_0,__IPHONE_5_0);
+    // returns a pointer to the first garbage collected zone created.
+
+
+/************ DELETED ***********/
+
+AUTO_EXPORT void auto_zone_stats(void)
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT void auto_zone_start_monitor(boolean_t force)
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT void auto_zone_set_class_list(int (*get_class_list)(void **buffer, int count))
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT void auto_zone_write_stats(FILE *f)
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT char *auto_zone_stats_string()
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT double auto_zone_utilization(auto_zone_t *zone) 
+    UNAVAILABLE_ATTRIBUTE;
+AUTO_EXPORT unsigned auto_zone_touched_size(auto_zone_t *zone) 
+    UNAVAILABLE_ATTRIBUTE;
+    
+
+/************* EXPERIMENTAL *********/
+#ifdef __BLOCKS__
+
+typedef void (^auto_zone_stack_dump)(const void *base, unsigned long byte_size);
+typedef void (^auto_zone_register_dump)(const void *base, unsigned long byte_size);
+typedef void (^auto_zone_node_dump)(const void *address, unsigned long size, unsigned int layout, unsigned long refcount);
+typedef void (^auto_zone_root_dump)(const void **address);
+typedef void (^auto_zone_weak_dump)(const void **address, const void *item);
+
+// Instruments.app utility; causes significant disruption.
+// This is SPI for Apple's use only.  Can and likely will change without regard to 3rd party use.
+AUTO_EXPORT void auto_zone_dump(auto_zone_t *zone,
+            auto_zone_stack_dump stack_dump,
+            auto_zone_register_dump register_dump,
+            auto_zone_node_dump thread_local_node_dump, // unsupported
+            auto_zone_root_dump root_dump,
+            auto_zone_node_dump global_node_dump,
+            auto_zone_weak_dump weak_dump)
+    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7, __IPHONE_5_0,__IPHONE_5_0);
+
+// auto_zone_dump() is now deprecated, use auto_zone_visit() instead.
+
+typedef struct {
+    void *begin;
+    void *end;
+} auto_address_range_t;
+
+typedef struct {
+    uint32_t version;                    // sizeof(auto_zone_visitor_t)
+    void (^visit_thread)(pthread_t thread, auto_address_range_t stack_range, auto_address_range_t registers);
+    void (^visit_node)(const void *address, size_t size, auto_memory_type_t type, uint32_t refcount, boolean_t is_thread_local);
+    void (^visit_root)(const void **address);
+    void (^visit_weak)(const void *value, void *const*location, auto_weak_callback_block_t *callback);
+    void (^visit_association)(const void *object, const void *key, const void *value);
+} auto_zone_visitor_t;
+
+AUTO_EXPORT void auto_zone_visit(auto_zone_t *zone, auto_zone_visitor_t *visitor)
+    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0);
+
+enum {
+    auto_is_not_auto  =    0,
+    auto_is_auto      =    (1 << 1),   // always on for a start of a node
+    auto_is_local     =    (1 << 2),   // is/was node local
+};
+
+typedef int auto_probe_results_t;
+
+// Instruments.app utility; causes significant disruption.
+// This is SPI for Apple's use only.  Can and likely will change without regard to 3rd party use.
+AUTO_EXPORT auto_probe_results_t auto_zone_probe_unlocked(auto_zone_t *zone, void *address)
+    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+AUTO_EXPORT void auto_zone_scan_exact(auto_zone_t *zone, void *address, void (^callback)(void *base, unsigned long byte_offset, void *candidate))
+     __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);
+
+#endif
+
+__END_DECLS
+
+#endif /* __AUTO_ZONE__ */
diff --git a/include/dispatch/benchmark.h b/include/dispatch/benchmark.h
new file mode 100755
index 0000000..df42a8a
--- /dev/null
+++ b/include/dispatch/benchmark.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2008-2009 Apple Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+
+/*
+ * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
+ * which are subject to change in future releases of Mac OS X. Any applications
+ * relying on these interfaces WILL break.
+ */
+
+#ifndef __DISPATCH_BENCHMARK__
+#define __DISPATCH_BENCHMARK__
+
+#ifndef __DISPATCH_INDIRECT__
+#error "Please #include <dispatch/dispatch.h> instead of this file directly."
+#include <dispatch/base.h> // for HeaderDoc
+#endif
+
+__BEGIN_DECLS
+
+/*!
+ * @function dispatch_benchmark
+ *
+ * @abstract
+ * Count the average number of cycles a given block takes to execute.
+ *
+ * @param count
+ * The number of times to serially execute the given block.
+ *
+ * @param block
+ * The block to execute.
+ *
+ * @result
+ * The approximate number of cycles the block takes to execute.
+ *
+ * @discussion
+ * This function is for debugging and performance analysis work. For the best
+ * results, pass a high count value to dispatch_benchmark(). When benchmarking
+ * concurrent code, please compare the serial version of the code against the
+ * concurrent version, and compare the concurrent version on different classes
+ * of hardware. Please look for inflection points with various data sets and
+ * keep the following facts in mind:
+ *
+ * 1) Code bound by computational bandwidth may be inferred by proportional
+ *    changes in performance as concurrency is increased.
+ * 2) Code bound by memory bandwidth may be inferred by negligible changes in
+ *    performance as concurrency is increased.
+ * 3) Code bound by critical sections may be inferred by retrograde changes in
+ *    performance as concurrency is increased.
+ * 3a) Intentional: locks, mutexes, and condition variables.
+ * 3b) Accidental: unrelated and frequently modified data on the same
+ *     cache-line.
+ */
+#ifdef __BLOCKS__
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NOTHROW
+uint64_t
+dispatch_benchmark(size_t count, void (^block)(void));
+#endif
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_NOTHROW
+uint64_t
+dispatch_benchmark_f(size_t count, void *ctxt, void (*func)(void *));
+
+__END_DECLS
+
+#endif
diff --git a/include/dispatch/private.h b/include/dispatch/private.h
new file mode 100755
index 0000000..9bb0e01
--- /dev/null
+++ b/include/dispatch/private.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+
+/*
+ * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
+ * which are subject to change in future releases of Mac OS X. Any applications
+ * relying on these interfaces WILL break.
+ */
+
+#ifndef __DISPATCH_PRIVATE__
+#define __DISPATCH_PRIVATE__
+
+#ifdef __APPLE__
+#include <TargetConditionals.h>
+#endif
+
+#if TARGET_OS_MAC
+#include <mach/boolean.h>
+#include <mach/mach.h>
+#include <mach/message.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_CDEFS_H
+#include <sys/cdefs.h>
+#endif
+#include <pthread.h>
+
+#define DISPATCH_NO_LEGACY 1
+#ifdef DISPATCH_LEGACY // <rdar://problem/7366725>
+#error "Dispatch legacy API unavailable."
+#endif
+
+#ifndef __DISPATCH_BUILDING_DISPATCH__
+#include_next <dispatch/dispatch.h>
+
+// Workaround <rdar://problem/6597365/>
+#ifndef __DISPATCH_PUBLIC__
+#include "/usr/include/dispatch/dispatch.h"
+#endif
+
+#ifndef __DISPATCH_INDIRECT__
+#define __DISPATCH_INDIRECT__
+#endif
+
+#include <dispatch/benchmark.h>
+#include <dispatch/queue_private.h>
+#include <dispatch/source_private.h>
+
+#undef __DISPATCH_INDIRECT__
+
+#endif /* !__DISPATCH_BUILDING_DISPATCH__ */
+
+/* LEGACY: Use DISPATCH_API_VERSION */
+#define LIBDISPATCH_VERSION DISPATCH_API_VERSION
+
+__BEGIN_DECLS
+
+DISPATCH_EXPORT DISPATCH_NOTHROW
+void
+libdispatch_init(void);
+
+#if TARGET_OS_MAC
+#define DISPATCH_COCOA_COMPAT 1
+#if DISPATCH_COCOA_COMPAT
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_CONST DISPATCH_WARN_RESULT DISPATCH_NOTHROW
+mach_port_t
+_dispatch_get_main_queue_port_4CF(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_NOTHROW
+void
+_dispatch_main_queue_callback_4CF(mach_msg_header_t *msg);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT
+void (*dispatch_begin_thread_4GC)(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT
+void (*dispatch_end_thread_4GC)(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_4_3)
+DISPATCH_EXPORT
+void (*dispatch_no_worker_threads_4GC)(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT
+void *(*_dispatch_begin_NSAutoReleasePool)(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT
+void (*_dispatch_end_NSAutoReleasePool)(void *);
+
+#define _dispatch_time_after_nsec(t) \
+		dispatch_time(DISPATCH_TIME_NOW, (t))
+#define _dispatch_time_after_usec(t) \
+		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_USEC)
+#define _dispatch_time_after_msec(t) \
+		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_MSEC)
+#define _dispatch_time_after_sec(t) \
+		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_SEC)
+
+#endif
+#endif /* TARGET_OS_MAC */
+
+/* pthreads magic */
+
+DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_prepare(void);
+DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_parent(void);
+DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_child(void);
+
+#if TARGET_OS_MAC
+/*
+ * Extract the context pointer from a mach message trailer.
+ */
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NONNULL_ALL
+DISPATCH_NOTHROW
+void *
+dispatch_mach_msg_get_context(mach_msg_header_t *msg);
+#endif /* TARGET_OS_MAC */
+
+__END_DECLS
+
+#endif
diff --git a/include/dispatch/queue_private.h b/include/dispatch/queue_private.h
new file mode 100755
index 0000000..5ec36d0
--- /dev/null
+++ b/include/dispatch/queue_private.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2008-2010 Apple Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+
+/*
+ * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
+ * which are subject to change in future releases of Mac OS X. Any applications
+ * relying on these interfaces WILL break.
+ */
+
+#ifndef __DISPATCH_QUEUE_PRIVATE__
+#define __DISPATCH_QUEUE_PRIVATE__
+
+#ifndef __DISPATCH_INDIRECT__
+#error "Please #include <dispatch/dispatch.h> instead of this file directly."
+#include <dispatch/base.h> // for HeaderDoc
+#endif
+
+__BEGIN_DECLS
+
+
+/*!
+ * @enum dispatch_queue_flags_t
+ *
+ * @constant DISPATCH_QUEUE_OVERCOMMIT
+ * The queue will create a new thread for invoking blocks, regardless of how
+ * busy the computer is.
+ */
+enum {
+	DISPATCH_QUEUE_OVERCOMMIT = 0x2ull,
+};
+
+#define DISPATCH_QUEUE_FLAGS_MASK (DISPATCH_QUEUE_OVERCOMMIT)
+
+/*!
+ * @function dispatch_queue_set_width
+ *
+ * @abstract
+ * Set the width of concurrency for a given queue. The width of a serial queue
+ * is one.
+ *
+ * @discussion
+ * This SPI is DEPRECATED and will be removed in a future release.
+ * Uses of this SPI to make a queue concurrent by setting its width to LONG_MAX
+ * should be replaced by passing DISPATCH_QUEUE_CONCURRENT to
+ * dispatch_queue_create().
+ * Uses of this SPI to limit queue concurrency are not recommended and should
+ * be replaced by alternative mechanisms such as a dispatch semaphore created
+ * with the desired concurrency width.
+ *
+ * @param queue
+ * The queue to adjust. Passing the main queue or a global concurrent queue
+ * will be ignored.
+ *
+ * @param width
+ * The new maximum width of concurrency depending on available resources.
+ * If zero is passed, then the value is promoted to one.
+ * Negative values are magic values that map to automatic width values.
+ * Unknown negative values default to DISPATCH_QUEUE_WIDTH_MAX_LOGICAL_CPUS.
+ */
+#define DISPATCH_QUEUE_WIDTH_ACTIVE_CPUS		-1
+#define DISPATCH_QUEUE_WIDTH_MAX_PHYSICAL_CPUS	-2
+#define DISPATCH_QUEUE_WIDTH_MAX_LOGICAL_CPUS	-3
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
+void
+dispatch_queue_set_width(dispatch_queue_t dq, long width); // DEPRECATED
+
+/*!
+ * @function dispatch_set_current_target_queue
+ *
+ * @abstract
+ * Synchronously sets the target queue of the current serial queue.
+ *
+ * @discussion
+ * This SPI is provided for a limited purpose case when calling
+ * dispatch_set_target_queue() is not sufficient. It works similarly to
+ * dispatch_set_target_queue() except the target queue of the current queue
+ * is immediately changed so that pending blocks on the queue will run on the
+ * new target queue. Calling this from outside of a block executing on a serial
+ * queue is undefined.
+ *
+ * @param queue
+ * The new target queue for the object. The queue is retained, and the
+ * previous target queue, if any, is released.
+ * If queue is DISPATCH_TARGET_QUEUE_DEFAULT, set the object's target queue
+ * to the default target queue for the given object type.
+ */
+
+__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0)
+DISPATCH_EXPORT DISPATCH_NOTHROW
+void
+dispatch_set_current_target_queue(dispatch_queue_t queue);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT const struct dispatch_queue_offsets_s {
+	// always add new fields at the end
+	const uint16_t dqo_version;
+	const uint16_t dqo_label;
+	const uint16_t dqo_label_size;
+	const uint16_t dqo_flags;
+	const uint16_t dqo_flags_size;
+	const uint16_t dqo_serialnum;
+	const uint16_t dqo_serialnum_size;
+	const uint16_t dqo_width;
+	const uint16_t dqo_width_size;
+	const uint16_t dqo_running;
+	const uint16_t dqo_running_size;
+} dispatch_queue_offsets;
+
+
+__END_DECLS
+
+#endif
diff --git a/include/dispatch/source_private.h b/include/dispatch/source_private.h
new file mode 100755
index 0000000..576f64a
--- /dev/null
+++ b/include/dispatch/source_private.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+
+/*
+ * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
+ * which are subject to change in future releases of Mac OS X. Any applications
+ * relying on these interfaces WILL break.
+ */
+
+#ifndef __DISPATCH_SOURCE_PRIVATE__
+#define __DISPATCH_SOURCE_PRIVATE__
+
+#ifndef __DISPATCH_INDIRECT__
+#error "Please #include <dispatch/dispatch.h> instead of this file directly."
+#include <dispatch/base.h> // for HeaderDoc
+#endif
+
+/*!
+ * @const DISPATCH_SOURCE_TYPE_VFS
+ * @discussion Apple-internal dispatch source that monitors for vfs events
+ * defined by dispatch_vfs_flags_t.
+ * The handle is a process identifier (pid_t).
+ */
+#define DISPATCH_SOURCE_TYPE_VFS (&_dispatch_source_type_vfs)
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT const struct dispatch_source_type_s _dispatch_source_type_vfs;
+
+/*!
+ * @const DISPATCH_SOURCE_TYPE_VM
+ * @discussion A dispatch source that monitors virtual memory
+ * The mask is a mask of desired events from dispatch_source_vm_flags_t.
+ */
+#define DISPATCH_SOURCE_TYPE_VM (&_dispatch_source_type_vm)
+__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_4_3)
+DISPATCH_EXPORT const struct dispatch_source_type_s _dispatch_source_type_vm;
+
+/*!
+ * @enum dispatch_source_vfs_flags_t
+ *
+ * @constant DISPATCH_VFS_NOTRESP
+ * Server down.
+ *
+ * @constant DISPATCH_VFS_NEEDAUTH
+ * Server bad auth.
+ *
+ * @constant DISPATCH_VFS_LOWDISK
+ * We're low on space.
+ *
+ * @constant DISPATCH_VFS_MOUNT
+ * New filesystem arrived.
+ *
+ * @constant DISPATCH_VFS_UNMOUNT
+ * Filesystem has left.
+ *
+ * @constant DISPATCH_VFS_DEAD
+ * Filesystem is dead, needs force unmount.
+ *
+ * @constant DISPATCH_VFS_ASSIST
+ * Filesystem needs assistance from external program.
+ *
+ * @constant DISPATCH_VFS_NOTRESPLOCK
+ * Server lockd down.
+ *
+ * @constant DISPATCH_VFS_UPDATE
+ * Filesystem information has changed.
+ *
+ * @constant DISPATCH_VFS_VERYLOWDISK
+ * File system has *very* little disk space left.
+ */
+enum {
+	DISPATCH_VFS_NOTRESP = 0x0001,
+	DISPATCH_VFS_NEEDAUTH = 0x0002,
+	DISPATCH_VFS_LOWDISK = 0x0004,
+	DISPATCH_VFS_MOUNT = 0x0008,
+	DISPATCH_VFS_UNMOUNT = 0x0010,
+	DISPATCH_VFS_DEAD = 0x0020,
+	DISPATCH_VFS_ASSIST = 0x0040,
+	DISPATCH_VFS_NOTRESPLOCK = 0x0080,
+	DISPATCH_VFS_UPDATE = 0x0100,
+	DISPATCH_VFS_VERYLOWDISK = 0x0200,
+};
+
+/*!
+ * @enum dispatch_source_mach_send_flags_t
+ *
+ * @constant DISPATCH_MACH_SEND_POSSIBLE
+ * The mach port corresponding to the given send right has space available
+ * for messages. Delivered only once a mach_msg() to that send right with
+ * options MACH_SEND_MSG|MACH_SEND_TIMEOUT|MACH_SEND_NOTIFY has returned
+ * MACH_SEND_TIMED_OUT (and not again until the next such mach_msg() timeout).
+ * NOTE: The source must have registered the send right for monitoring with the
+ *       system for such a mach_msg() to arm the send-possible notifcation, so
+ *       the initial send attempt must occur from a source registration handler.
+ */
+enum {
+	DISPATCH_MACH_SEND_POSSIBLE = 0x8,
+};
+
+/*!
+ * @enum dispatch_source_proc_flags_t
+ *
+ * @constant DISPATCH_PROC_REAP
+ * The process has been reaped by the parent process via
+ * wait*().
+ */
+enum {
+	DISPATCH_PROC_REAP = 0x10000000,
+};
+
+/*!
+ * @enum dispatch_source_vm_flags_t
+ *
+ * @constant DISPATCH_VM_PRESSURE
+ * The VM has experienced memory pressure.
+ */
+
+enum {
+	DISPATCH_VM_PRESSURE = 0x80000000,
+};
+
+#if TARGET_IPHONE_SIMULATOR // rdar://problem/9219483
+#define DISPATCH_VM_PRESSURE DISPATCH_VNODE_ATTRIB
+#endif
+
+__BEGIN_DECLS
+
+#if TARGET_OS_MAC
+/*!
+ * @typedef dispatch_mig_callback_t
+ *
+ * @abstract
+ * The signature of a function that handles Mach message delivery and response.
+ */
+typedef boolean_t (*dispatch_mig_callback_t)(mach_msg_header_t *message,
+		mach_msg_header_t *reply);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
+DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
+mach_msg_return_t
+dispatch_mig_server(dispatch_source_t ds, size_t maxmsgsz,
+		dispatch_mig_callback_t callback);
+#endif
+
+__END_DECLS
+
+#endif
diff --git a/include/libkern/OSCrossEndian.h b/include/libkern/OSCrossEndian.h
new file mode 100755
index 0000000..0bbbf58
--- /dev/null
+++ b/include/libkern/OSCrossEndian.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+/*
+ * This private header exports 3 APIs.
+ *	_OSRosettaCheck() - 	An inline function that returns true if we are
+ *				currently running under Rosetta.
+ *	IF_ROSETTA() -		Which is used to as a regular conditional
+ *				expression that is true only if the current
+ *				code is executing in the Rosetta
+ *				translation space.
+ *	ROSETTA_ONLY(exprs) - 	Which is used to create a block code that only
+ *				executes if we are running in Rosetta.
+ *
+ * for example
+ *
+ * IF_ROSETTA() {
+ *	// Do Cross endian swapping of input data
+ *	outdata = OSSwap??(indata);
+ * }
+ * else {
+ * 	// Do straight through 
+ *	outdata = indata;
+ * }
+ *
+ * outdata = indata;
+ * ROSETTA_ONLY(
+ *	// Do Cross endian swapping of input data
+ *	outdata = OSSwap??(outdata);
+ * );
+ */
+
+#ifndef _LIBKERN_OSCROSSENDIAN_H
+#define _LIBKERN_OSCROSSENDIAN_H
+
+#include <sys/sysctl.h>
+
+#if __ppc__
+
+static __inline__ int
+_OSRosettaCheck(void)
+{
+	int isCrossEndian = 0;
+	int val = 0;
+	size_t size = sizeof val;
+
+	if (sysctlbyname("sysctl.proc_native", &val, &size, NULL, 0) == -1)
+		isCrossEndian = 0;
+	else
+		isCrossEndian = val ? 0 : 1;
+
+	return isCrossEndian;
+}
+
+#else /* __ppc__ */
+
+static __inline__ int _OSRosettaCheck(void) { return 0; }
+
+#endif /* __ppc__ */
+
+#define IF_ROSETTA() if (__builtin_expect(_OSRosettaCheck(), 0) )
+
+#define ROSETTA_ONLY(exprs)	\
+do {				\
+    IF_ROSETTA() {		\
+	exprs			\
+    }				\
+} while(0)
+
+#endif /*  _LIBKERN_OSCROSSENDIAN_H */
diff --git a/include/mach-o/dyld_priv.h b/include/mach-o/dyld_priv.h
new file mode 100755
index 0000000..07ef161
--- /dev/null
+++ b/include/mach-o/dyld_priv.h
@@ -0,0 +1,125 @@
+/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
+ *
+ * Copyright (c) 2003-2008 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+#ifndef _MACH_O_DYLD_PRIV_H_
+#define _MACH_O_DYLD_PRIV_H_
+
+
+#include <mach-o/dyld.h>
+#include <mach-o/dyld_images.h>
+
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+//
+// Possible state changes for which you can register to be notified
+//
+enum dyld_image_states
+{
+	dyld_image_state_mapped					= 10,		// No batch notification for this
+	dyld_image_state_dependents_mapped		= 20,		// Only batch notification for this
+	dyld_image_state_rebased				= 30, 
+	dyld_image_state_bound					= 40,
+	dyld_image_state_dependents_initialized	= 45,		// Only single notification for this
+	dyld_image_state_initialized			= 50,
+	dyld_image_state_terminated				= 60		// Only single notification for this
+};
+
+// 
+// Callback that provides a bottom-up array of images
+// For dyld_image_state_[dependents_]mapped state only, returning non-NULL will cause dyld to abort loading all those images
+// and append the returned string to its load failure error message. dyld does not free the string, so
+// it should be a literal string or a static buffer
+//
+typedef const char* (*dyld_image_state_change_handler)(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info info[]);
+
+//
+// Register a handler to be called when any image changes to the requested state.
+// If 'batch' is true, the callback is called with an array of all images that are in the requested state sorted by dependency.
+// If 'batch' is false, the callback is called with one image at a time as each image transitions to the the requested state.
+// During the call to this function, the handler may be called back with existing images and the handler should
+// not return a string, since there is no load to abort.  In batch mode, existing images at or past the request
+// state supplied in the callback.  In non-batch mode, the callback is called for each image exactly in the
+// requested state.    
+//
+extern void
+dyld_register_image_state_change_handler(enum dyld_image_states state, bool batch, dyld_image_state_change_handler handler);
+
+
+//
+// get slide for a given loaded mach_header  
+// Mac OS X 10.6 and later
+//
+extern intptr_t _dyld_get_image_slide(const struct mach_header* mh);
+
+
+//
+// get pointer to this process's dyld_all_image_infos
+// Exists in Mac OS X 10.4 and later through _dyld_func_lookup()
+// Exists in Mac OS X 10.6 and later through libSystem.dylib
+//
+const struct dyld_all_image_infos* _dyld_get_all_image_infos();
+
+
+
+struct dyld_unwind_sections
+{
+	const struct mach_header*		mh;
+	const void*						dwarf_section;
+	uintptr_t						dwarf_section_length;
+	const void*						compact_unwind_section;
+	uintptr_t						compact_unwind_section_length;
+};
+
+
+//
+// Returns true iff some loaded mach-o image contains "addr".
+//	info->mh							mach header of image containing addr
+//  info->dwarf_section					pointer to start of __TEXT/__eh_frame section
+//  info->dwarf_section_length			length of __TEXT/__eh_frame section
+//  info->compact_unwind_section		pointer to start of __TEXT/__unwind_info section
+//  info->compact_unwind_section_length	length of __TEXT/__unwind_info section
+//
+// Exists in Mac OS X 10.6 and later 
+extern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);
+
+
+//
+// This is an optimized form of dladdr() that only returns the dli_fname field.
+//
+// Exists in Mac OS X 10.6 and later 
+extern const char* dyld_image_path_containing_address(const void* addr);
+
+
+
+
+
+
+
+#if __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* _MACH_O_DYLD_PRIV_H_ */
diff --git a/include/mach/clock_reply_server.h b/include/mach/clock_reply_server.h
new file mode 100755
index 0000000..325f832
--- /dev/null
+++ b/include/mach/clock_reply_server.h
@@ -0,0 +1,140 @@
+#ifndef	_clock_reply_server_
+#define	_clock_reply_server_
+
+/* Module clock_reply */
+
+#include <string.h>
+#include <mach/ndr.h>
+#include <mach/boolean.h>
+#include <mach/kern_return.h>
+#include <mach/notify.h>
+#include <mach/mach_types.h>
+#include <mach/message.h>
+#include <mach/mig_errors.h>
+#include <mach/port.h>
+
+#ifdef AUTOTEST
+#ifndef FUNCTION_PTR_T
+#define FUNCTION_PTR_T
+typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
+typedef struct {
+        char            *name;
+        function_ptr_t  function;
+} function_table_entry;
+typedef function_table_entry   *function_table_t;
+#endif /* FUNCTION_PTR_T */
+#endif /* AUTOTEST */
+
+#ifndef	clock_reply_MSG_COUNT
+#define	clock_reply_MSG_COUNT	1
+#endif	/* clock_reply_MSG_COUNT */
+
+#include <mach/std_types.h>
+#include <mach/mig.h>
+#include <mach/mach_types.h>
+
+#ifdef __BeforeMigServerHeader
+__BeforeMigServerHeader
+#endif /* __BeforeMigServerHeader */
+
+
+/* SimpleRoutine clock_alarm_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t clock_alarm_reply
+(
+	clock_reply_t alarm_port,
+	kern_return_t alarm_code,
+	alarm_type_t alarm_type,
+	mach_timespec_t alarm_time
+);
+
+extern boolean_t clock_reply_server(
+		mach_msg_header_t *InHeadP,
+		mach_msg_header_t *OutHeadP);
+
+extern mig_routine_t clock_reply_server_routine(
+		mach_msg_header_t *InHeadP);
+
+
+/* Description of this subsystem, for use in direct RPC */
+extern const struct clock_reply_subsystem {
+	mig_server_routine_t	server;	/* Server routine */
+	mach_msg_id_t	start;	/* Min routine number */
+	mach_msg_id_t	end;	/* Max routine number + 1 */
+	unsigned int	maxsize;	/* Max msg size */
+	vm_address_t	reserved;	/* Reserved */
+	struct routine_descriptor	/*Array of routine descriptors */
+		routine[1];
+} clock_reply_subsystem;
+
+/* typedefs for all requests */
+
+#ifndef __Request__clock_reply_subsystem__defined
+#define __Request__clock_reply_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t alarm_code;
+		alarm_type_t alarm_type;
+		mach_timespec_t alarm_time;
+	} __Request__clock_alarm_reply_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Request__clock_reply_subsystem__defined */
+
+
+/* union of all requests */
+
+#ifndef __RequestUnion__clock_reply_subsystem__defined
+#define __RequestUnion__clock_reply_subsystem__defined
+union __RequestUnion__clock_reply_subsystem {
+	__Request__clock_alarm_reply_t Request_clock_alarm_reply;
+};
+#endif /* __RequestUnion__clock_reply_subsystem__defined */
+/* typedefs for all replies */
+
+#ifndef __Reply__clock_reply_subsystem__defined
+#define __Reply__clock_reply_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__clock_alarm_reply_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Reply__clock_reply_subsystem__defined */
+
+
+/* union of all replies */
+
+#ifndef __ReplyUnion__clock_reply_subsystem__defined
+#define __ReplyUnion__clock_reply_subsystem__defined
+union __ReplyUnion__clock_reply_subsystem {
+	__Reply__clock_alarm_reply_t Reply_clock_alarm_reply;
+};
+#endif /* __RequestUnion__clock_reply_subsystem__defined */
+
+#ifndef subsystem_to_name_map_clock_reply
+#define subsystem_to_name_map_clock_reply \
+    { "clock_alarm_reply", 3125107 }
+#endif
+
+#ifdef __AfterMigServerHeader
+__AfterMigServerHeader
+#endif /* __AfterMigServerHeader */
+
+#endif	 /* _clock_reply_server_ */
diff --git a/include/mach/exc_server.h b/include/mach/exc_server.h
new file mode 100755
index 0000000..2f26071
--- /dev/null
+++ b/include/mach/exc_server.h
@@ -0,0 +1,263 @@
+#ifndef	_exc_server_
+#define	_exc_server_
+
+/* Module exc */
+
+#include <string.h>
+#include <mach/ndr.h>
+#include <mach/boolean.h>
+#include <mach/kern_return.h>
+#include <mach/notify.h>
+#include <mach/mach_types.h>
+#include <mach/message.h>
+#include <mach/mig_errors.h>
+#include <mach/port.h>
+
+#ifdef AUTOTEST
+#ifndef FUNCTION_PTR_T
+#define FUNCTION_PTR_T
+typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
+typedef struct {
+        char            *name;
+        function_ptr_t  function;
+} function_table_entry;
+typedef function_table_entry   *function_table_t;
+#endif /* FUNCTION_PTR_T */
+#endif /* AUTOTEST */
+
+#ifndef	exc_MSG_COUNT
+#define	exc_MSG_COUNT	3
+#endif	/* exc_MSG_COUNT */
+
+#include <mach/std_types.h>
+#include <mach/mig.h>
+#include <mach/mig.h>
+#include <mach/mach_types.h>
+
+#ifdef __BeforeMigServerHeader
+__BeforeMigServerHeader
+#endif /* __BeforeMigServerHeader */
+
+
+/* Routine exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	exception_type_t exception,
+	exception_data_t code,
+	mach_msg_type_number_t codeCnt
+);
+
+/* Routine exception_raise_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_exception_raise_state
+(
+	mach_port_t exception_port,
+	exception_type_t exception,
+	const exception_data_t code,
+	mach_msg_type_number_t codeCnt,
+	int *flavor,
+	const thread_state_t old_state,
+	mach_msg_type_number_t old_stateCnt,
+	thread_state_t new_state,
+	mach_msg_type_number_t *new_stateCnt
+);
+
+/* Routine exception_raise_state_identity */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_exception_raise_state_identity
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	exception_type_t exception,
+	exception_data_t code,
+	mach_msg_type_number_t codeCnt,
+	int *flavor,
+	thread_state_t old_state,
+	mach_msg_type_number_t old_stateCnt,
+	thread_state_t new_state,
+	mach_msg_type_number_t *new_stateCnt
+);
+
+extern boolean_t exc_server(
+		mach_msg_header_t *InHeadP,
+		mach_msg_header_t *OutHeadP);
+
+extern mig_routine_t exc_server_routine(
+		mach_msg_header_t *InHeadP);
+
+
+/* Description of this subsystem, for use in direct RPC */
+extern const struct catch_exc_subsystem {
+	mig_server_routine_t	server;	/* Server routine */
+	mach_msg_id_t	start;	/* Min routine number */
+	mach_msg_id_t	end;	/* Max routine number + 1 */
+	unsigned int	maxsize;	/* Max msg size */
+	vm_address_t	reserved;	/* Reserved */
+	struct routine_descriptor	/*Array of routine descriptors */
+		routine[3];
+} catch_exc_subsystem;
+
+/* typedefs for all requests */
+
+#ifndef __Request__exc_subsystem__defined
+#define __Request__exc_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		/* start of the kernel processed data */
+		mach_msg_body_t msgh_body;
+		mach_msg_port_descriptor_t thread;
+		mach_msg_port_descriptor_t task;
+		/* end of the kernel processed data */
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		integer_t code[2];
+	} __Request__exception_raise_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		integer_t code[2];
+		int flavor;
+		mach_msg_type_number_t old_stateCnt;
+		natural_t old_state[144];
+	} __Request__exception_raise_state_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		/* start of the kernel processed data */
+		mach_msg_body_t msgh_body;
+		mach_msg_port_descriptor_t thread;
+		mach_msg_port_descriptor_t task;
+		/* end of the kernel processed data */
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		integer_t code[2];
+		int flavor;
+		mach_msg_type_number_t old_stateCnt;
+		natural_t old_state[144];
+	} __Request__exception_raise_state_identity_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Request__exc_subsystem__defined */
+
+
+/* union of all requests */
+
+#ifndef __RequestUnion__catch_exc_subsystem__defined
+#define __RequestUnion__catch_exc_subsystem__defined
+union __RequestUnion__catch_exc_subsystem {
+	__Request__exception_raise_t Request_exception_raise;
+	__Request__exception_raise_state_t Request_exception_raise_state;
+	__Request__exception_raise_state_identity_t Request_exception_raise_state_identity;
+};
+#endif /* __RequestUnion__catch_exc_subsystem__defined */
+/* typedefs for all replies */
+
+#ifndef __Reply__exc_subsystem__defined
+#define __Reply__exc_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__exception_raise_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+		int flavor;
+		mach_msg_type_number_t new_stateCnt;
+		natural_t new_state[144];
+	} __Reply__exception_raise_state_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+		int flavor;
+		mach_msg_type_number_t new_stateCnt;
+		natural_t new_state[144];
+	} __Reply__exception_raise_state_identity_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Reply__exc_subsystem__defined */
+
+
+/* union of all replies */
+
+#ifndef __ReplyUnion__catch_exc_subsystem__defined
+#define __ReplyUnion__catch_exc_subsystem__defined
+union __ReplyUnion__catch_exc_subsystem {
+	__Reply__exception_raise_t Reply_exception_raise;
+	__Reply__exception_raise_state_t Reply_exception_raise_state;
+	__Reply__exception_raise_state_identity_t Reply_exception_raise_state_identity;
+};
+#endif /* __RequestUnion__catch_exc_subsystem__defined */
+
+#ifndef subsystem_to_name_map_exc
+#define subsystem_to_name_map_exc \
+    { "exception_raise", 2401 },\
+    { "exception_raise_state", 2402 },\
+    { "exception_raise_state_identity", 2403 }
+#endif
+
+#ifdef __AfterMigServerHeader
+__AfterMigServerHeader
+#endif /* __AfterMigServerHeader */
+
+#endif	 /* _exc_server_ */
diff --git a/include/mach/mach_exc_server.h b/include/mach/mach_exc_server.h
new file mode 100755
index 0000000..d537ff0
--- /dev/null
+++ b/include/mach/mach_exc_server.h
@@ -0,0 +1,263 @@
+#ifndef	_mach_exc_server_
+#define	_mach_exc_server_
+
+/* Module mach_exc */
+
+#include <string.h>
+#include <mach/ndr.h>
+#include <mach/boolean.h>
+#include <mach/kern_return.h>
+#include <mach/notify.h>
+#include <mach/mach_types.h>
+#include <mach/message.h>
+#include <mach/mig_errors.h>
+#include <mach/port.h>
+
+#ifdef AUTOTEST
+#ifndef FUNCTION_PTR_T
+#define FUNCTION_PTR_T
+typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
+typedef struct {
+        char            *name;
+        function_ptr_t  function;
+} function_table_entry;
+typedef function_table_entry   *function_table_t;
+#endif /* FUNCTION_PTR_T */
+#endif /* AUTOTEST */
+
+#ifndef	mach_exc_MSG_COUNT
+#define	mach_exc_MSG_COUNT	3
+#endif	/* mach_exc_MSG_COUNT */
+
+#include <mach/std_types.h>
+#include <mach/mig.h>
+#include <mach/mig.h>
+#include <mach/mach_types.h>
+
+#ifdef __BeforeMigServerHeader
+__BeforeMigServerHeader
+#endif /* __BeforeMigServerHeader */
+
+
+/* Routine mach_exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_mach_exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	exception_type_t exception,
+	mach_exception_data_t code,
+	mach_msg_type_number_t codeCnt
+);
+
+/* Routine mach_exception_raise_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_mach_exception_raise_state
+(
+	mach_port_t exception_port,
+	exception_type_t exception,
+	const mach_exception_data_t code,
+	mach_msg_type_number_t codeCnt,
+	int *flavor,
+	const thread_state_t old_state,
+	mach_msg_type_number_t old_stateCnt,
+	thread_state_t new_state,
+	mach_msg_type_number_t *new_stateCnt
+);
+
+/* Routine mach_exception_raise_state_identity */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t catch_mach_exception_raise_state_identity
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	exception_type_t exception,
+	mach_exception_data_t code,
+	mach_msg_type_number_t codeCnt,
+	int *flavor,
+	thread_state_t old_state,
+	mach_msg_type_number_t old_stateCnt,
+	thread_state_t new_state,
+	mach_msg_type_number_t *new_stateCnt
+);
+
+extern boolean_t mach_exc_server(
+		mach_msg_header_t *InHeadP,
+		mach_msg_header_t *OutHeadP);
+
+extern mig_routine_t mach_exc_server_routine(
+		mach_msg_header_t *InHeadP);
+
+
+/* Description of this subsystem, for use in direct RPC */
+extern const struct catch_mach_exc_subsystem {
+	mig_server_routine_t	server;	/* Server routine */
+	mach_msg_id_t	start;	/* Min routine number */
+	mach_msg_id_t	end;	/* Max routine number + 1 */
+	unsigned int	maxsize;	/* Max msg size */
+	vm_address_t	reserved;	/* Reserved */
+	struct routine_descriptor	/*Array of routine descriptors */
+		routine[3];
+} catch_mach_exc_subsystem;
+
+/* typedefs for all requests */
+
+#ifndef __Request__mach_exc_subsystem__defined
+#define __Request__mach_exc_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		/* start of the kernel processed data */
+		mach_msg_body_t msgh_body;
+		mach_msg_port_descriptor_t thread;
+		mach_msg_port_descriptor_t task;
+		/* end of the kernel processed data */
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		int64_t code[2];
+	} __Request__mach_exception_raise_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		int64_t code[2];
+		int flavor;
+		mach_msg_type_number_t old_stateCnt;
+		natural_t old_state[144];
+	} __Request__mach_exception_raise_state_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		/* start of the kernel processed data */
+		mach_msg_body_t msgh_body;
+		mach_msg_port_descriptor_t thread;
+		mach_msg_port_descriptor_t task;
+		/* end of the kernel processed data */
+		NDR_record_t NDR;
+		exception_type_t exception;
+		mach_msg_type_number_t codeCnt;
+		int64_t code[2];
+		int flavor;
+		mach_msg_type_number_t old_stateCnt;
+		natural_t old_state[144];
+	} __Request__mach_exception_raise_state_identity_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Request__mach_exc_subsystem__defined */
+
+
+/* union of all requests */
+
+#ifndef __RequestUnion__catch_mach_exc_subsystem__defined
+#define __RequestUnion__catch_mach_exc_subsystem__defined
+union __RequestUnion__catch_mach_exc_subsystem {
+	__Request__mach_exception_raise_t Request_mach_exception_raise;
+	__Request__mach_exception_raise_state_t Request_mach_exception_raise_state;
+	__Request__mach_exception_raise_state_identity_t Request_mach_exception_raise_state_identity;
+};
+#endif /* __RequestUnion__catch_mach_exc_subsystem__defined */
+/* typedefs for all replies */
+
+#ifndef __Reply__mach_exc_subsystem__defined
+#define __Reply__mach_exc_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_exception_raise_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+		int flavor;
+		mach_msg_type_number_t new_stateCnt;
+		natural_t new_state[144];
+	} __Reply__mach_exception_raise_state_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+		int flavor;
+		mach_msg_type_number_t new_stateCnt;
+		natural_t new_state[144];
+	} __Reply__mach_exception_raise_state_identity_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Reply__mach_exc_subsystem__defined */
+
+
+/* union of all replies */
+
+#ifndef __ReplyUnion__catch_mach_exc_subsystem__defined
+#define __ReplyUnion__catch_mach_exc_subsystem__defined
+union __ReplyUnion__catch_mach_exc_subsystem {
+	__Reply__mach_exception_raise_t Reply_mach_exception_raise;
+	__Reply__mach_exception_raise_state_t Reply_mach_exception_raise_state;
+	__Reply__mach_exception_raise_state_identity_t Reply_mach_exception_raise_state_identity;
+};
+#endif /* __RequestUnion__catch_mach_exc_subsystem__defined */
+
+#ifndef subsystem_to_name_map_mach_exc
+#define subsystem_to_name_map_mach_exc \
+    { "mach_exception_raise", 2405 },\
+    { "mach_exception_raise_state", 2406 },\
+    { "mach_exception_raise_state_identity", 2407 }
+#endif
+
+#ifdef __AfterMigServerHeader
+__AfterMigServerHeader
+#endif /* __AfterMigServerHeader */
+
+#endif	 /* _mach_exc_server_ */
diff --git a/include/mach/notify_server.h b/include/mach/notify_server.h
new file mode 100755
index 0000000..780a4b9
--- /dev/null
+++ b/include/mach/notify_server.h
@@ -0,0 +1,290 @@
+#ifndef	_notify_server_
+#define	_notify_server_
+
+/* Module notify */
+
+#include <string.h>
+#include <mach/ndr.h>
+#include <mach/boolean.h>
+#include <mach/kern_return.h>
+#include <mach/notify.h>
+#include <mach/mach_types.h>
+#include <mach/message.h>
+#include <mach/mig_errors.h>
+#include <mach/port.h>
+
+#ifdef AUTOTEST
+#ifndef FUNCTION_PTR_T
+#define FUNCTION_PTR_T
+typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
+typedef struct {
+        char            *name;
+        function_ptr_t  function;
+} function_table_entry;
+typedef function_table_entry   *function_table_t;
+#endif /* FUNCTION_PTR_T */
+#endif /* AUTOTEST */
+
+#ifndef	notify_MSG_COUNT
+#define	notify_MSG_COUNT	9
+#endif	/* notify_MSG_COUNT */
+
+#include <mach/std_types.h>
+#include <mach/mig.h>
+
+#ifdef __BeforeMigServerHeader
+__BeforeMigServerHeader
+#endif /* __BeforeMigServerHeader */
+
+
+/* SimpleRoutine mach_notify_port_deleted */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t do_mach_notify_port_deleted
+(
+	mach_port_t notify,
+	mach_port_name_t name
+);
+
+/* SimpleRoutine mach_notify_port_destroyed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t do_mach_notify_port_destroyed
+(
+	mach_port_t notify,
+	mach_port_t rights
+);
+
+/* SimpleRoutine mach_notify_no_senders */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t do_mach_notify_no_senders
+(
+	mach_port_t notify,
+	mach_port_mscount_t mscount
+);
+
+/* SimpleRoutine mach_notify_send_once */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t do_mach_notify_send_once
+(
+	mach_port_t notify
+);
+
+/* SimpleRoutine mach_notify_dead_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif	/* mig_external */
+kern_return_t do_mach_notify_dead_name
+(
+	mach_port_t notify,
+	mach_port_name_t name
+);
+
+extern boolean_t notify_server(
+		mach_msg_header_t *InHeadP,
+		mach_msg_header_t *OutHeadP);
+
+extern mig_routine_t notify_server_routine(
+		mach_msg_header_t *InHeadP);
+
+
+/* Description of this subsystem, for use in direct RPC */
+extern const struct do_notify_subsystem {
+	mig_server_routine_t	server;	/* Server routine */
+	mach_msg_id_t	start;	/* Min routine number */
+	mach_msg_id_t	end;	/* Max routine number + 1 */
+	unsigned int	maxsize;	/* Max msg size */
+	vm_address_t	reserved;	/* Reserved */
+	struct routine_descriptor	/*Array of routine descriptors */
+		routine[9];
+} do_notify_subsystem;
+
+/* typedefs for all requests */
+
+#ifndef __Request__notify_subsystem__defined
+#define __Request__notify_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		mach_port_name_t name;
+	} __Request__mach_notify_port_deleted_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		/* start of the kernel processed data */
+		mach_msg_body_t msgh_body;
+		mach_msg_port_descriptor_t rights;
+		/* end of the kernel processed data */
+	} __Request__mach_notify_port_destroyed_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		mach_port_mscount_t mscount;
+	} __Request__mach_notify_no_senders_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+	} __Request__mach_notify_send_once_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		mach_port_name_t name;
+	} __Request__mach_notify_dead_name_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Request__notify_subsystem__defined */
+
+
+/* union of all requests */
+
+#ifndef __RequestUnion__do_notify_subsystem__defined
+#define __RequestUnion__do_notify_subsystem__defined
+union __RequestUnion__do_notify_subsystem {
+	__Request__mach_notify_port_deleted_t Request_mach_notify_port_deleted;
+	__Request__mach_notify_port_destroyed_t Request_mach_notify_port_destroyed;
+	__Request__mach_notify_no_senders_t Request_mach_notify_no_senders;
+	__Request__mach_notify_send_once_t Request_mach_notify_send_once;
+	__Request__mach_notify_dead_name_t Request_mach_notify_dead_name;
+};
+#endif /* __RequestUnion__do_notify_subsystem__defined */
+/* typedefs for all replies */
+
+#ifndef __Reply__notify_subsystem__defined
+#define __Reply__notify_subsystem__defined
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_notify_port_deleted_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_notify_port_destroyed_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_notify_no_senders_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_notify_send_once_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+
+#ifdef  __MigPackStructs
+#pragma pack(4)
+#endif
+	typedef struct {
+		mach_msg_header_t Head;
+		NDR_record_t NDR;
+		kern_return_t RetCode;
+	} __Reply__mach_notify_dead_name_t;
+#ifdef  __MigPackStructs
+#pragma pack()
+#endif
+#endif /* !__Reply__notify_subsystem__defined */
+
+
+/* union of all replies */
+
+#ifndef __ReplyUnion__do_notify_subsystem__defined
+#define __ReplyUnion__do_notify_subsystem__defined
+union __ReplyUnion__do_notify_subsystem {
+	__Reply__mach_notify_port_deleted_t Reply_mach_notify_port_deleted;
+	__Reply__mach_notify_port_destroyed_t Reply_mach_notify_port_destroyed;
+	__Reply__mach_notify_no_senders_t Reply_mach_notify_no_senders;
+	__Reply__mach_notify_send_once_t Reply_mach_notify_send_once;
+	__Reply__mach_notify_dead_name_t Reply_mach_notify_dead_name;
+};
+#endif /* __RequestUnion__do_notify_subsystem__defined */
+
+#ifndef subsystem_to_name_map_notify
+#define subsystem_to_name_map_notify \
+    { "mach_notify_port_deleted", 65 },\
+    { "mach_notify_port_destroyed", 69 },\
+    { "mach_notify_no_senders", 70 },\
+    { "mach_notify_send_once", 71 },\
+    { "mach_notify_dead_name", 72 }
+#endif
+
+#ifdef __AfterMigServerHeader
+__AfterMigServerHeader
+#endif /* __AfterMigServerHeader */
+
+#endif	 /* _notify_server_ */
diff --git a/include/machine/Makefile b/include/machine/Makefile
new file mode 100755
index 0000000..d68ef2f
--- /dev/null
+++ b/include/machine/Makefile
@@ -0,0 +1,31 @@
+export MakeInc_cmd=${SRCROOT}/makedefs/MakeInc.cmd
+export MakeInc_def=${SRCROOT}/makedefs/MakeInc.def
+export MakeInc_rule=${SRCROOT}/makedefs/MakeInc.rule
+export MakeInc_dir=${SRCROOT}/makedefs/MakeInc.dir
+
+
+include $(MakeInc_cmd)
+include $(MakeInc_def)
+
+
+DATAFILES = \
+	cpu_number.h	\
+	cpu_capabilities.h	\
+	io_map_entries.h \
+	lock.h	\
+	locks.h	\
+	machine_routines.h	\
+	simple_lock.h
+
+INSTALL_MI_LCL_LIST = cpu_capabilities.h
+
+INSTALL_MI_DIR = machine
+
+EXPORT_MI_LIST = ${DATAFILES}
+
+EXPORT_MI_DIR = machine
+
+include $(MakeInc_rule)
+include $(MakeInc_dir)
+
+
diff --git a/include/machine/asm.h b/include/machine/asm.h
new file mode 100755
index 0000000..70c246c
--- /dev/null
+++ b/include/machine/asm.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_ASM_H
+#define _MACHINE_ASM_H
+
+#if defined (__ppc__)
+#include "ppc/asm.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/asm.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_ASM_H */
diff --git a/include/machine/ast.h b/include/machine/ast.h
new file mode 100755
index 0000000..0c01fc7
--- /dev/null
+++ b/include/machine/ast.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_AST_H
+#define _MACHINE_AST_H
+
+#if defined (__ppc__)
+#include "ppc/ast.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/ast.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_AST_H */
diff --git a/include/machine/ast_types.h b/include/machine/ast_types.h
new file mode 100755
index 0000000..fc7d1d2
--- /dev/null
+++ b/include/machine/ast_types.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_AST_TYPES_H
+#define _MACHINE_AST_TYPES_H
+
+#if defined (__ppc__)
+#include "ppc/ast_types.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/ast_types.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_AST_TYPES_H */
diff --git a/include/machine/commpage.h b/include/machine/commpage.h
new file mode 100755
index 0000000..c3d3a99
--- /dev/null
+++ b/include/machine/commpage.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef _MACHINE_COMMPAGE_H
+#define _MACHINE_COMMPAGE_H
+
+#if defined (__ppc__)
+#include "ppc/commpage/commpage.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/commpage/commpage.h"
+#else
+#error architecture not supported
+#endif
+
+#ifndef	__ASSEMBLER__
+
+extern	void	commpage_populate( void ); 	/* called once during startup */
+
+#endif	/* __ASSEMBLER__ */
+
+#endif	/* _MACHINE_COMMPAGE_H */
diff --git a/include/machine/cpu_affinity.h b/include/machine/cpu_affinity.h
new file mode 100755
index 0000000..990c856
--- /dev/null
+++ b/include/machine/cpu_affinity.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	KERNEL_PRIVATE
+
+#ifndef _MACHINE_CPU_AFFINITY_H
+#define _MACHINE_CPU_AFFINITY_H
+
+#if defined (__ppc__)
+#include "ppc/cpu_affinity.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/cpu_affinity.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_CPU_AFFINITY_H */
+
+#endif	/* KERNEL_PRIVATE */
diff --git a/include/machine/cpu_capabilities.h b/include/machine/cpu_capabilities.h
new file mode 100755
index 0000000..606ec28
--- /dev/null
+++ b/include/machine/cpu_capabilities.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	PRIVATE
+
+#ifndef _MACHINE_CPU_CAPABILITIES_H
+#define _MACHINE_CPU_CAPABILITIES_H
+
+#ifdef KERNEL_PRIVATE
+#if defined (__ppc__)
+#include "ppc/cpu_capabilities.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/cpu_capabilities.h"
+#else
+#error architecture not supported
+#endif
+
+#else /* !KERNEL_PRIVATE -- System Framework header */
+#if defined (__ppc__) || defined(__ppc64__)
+#include <System/ppc/cpu_capabilities.h>
+#elif defined (__i386__) || defined(__x86_64__)
+#include <System/i386/cpu_capabilities.h>
+#else
+#error architecture not supported
+#endif
+#endif /* KERNEL_PRIVATE */
+
+#endif /* _MACHINE_CPU_CAPABILITIES_H */
+#endif /* PRIVATE */
diff --git a/include/machine/cpu_data.h b/include/machine/cpu_data.h
new file mode 100755
index 0000000..0a04748
--- /dev/null
+++ b/include/machine/cpu_data.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_CPU_DATA_H
+#define _MACHINE_CPU_DATA_H
+
+#if defined (__ppc__)
+#include "ppc/cpu_data.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/cpu_data.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_CPU_DATA_H */
diff --git a/include/machine/cpu_number.h b/include/machine/cpu_number.h
new file mode 100755
index 0000000..47e71ba
--- /dev/null
+++ b/include/machine/cpu_number.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	KERNEL_PRIVATE
+
+#ifndef _MACHINE_CPU_NUMBER_H
+#define _MACHINE_CPU_NUMBER_H
+
+#if defined (__ppc__)
+#include "ppc/cpu_number.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/cpu_number.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_CPU_NUMBER_H */
+
+#endif	/* KERNEL_PRIVATE */
diff --git a/include/machine/db_machdep.h b/include/machine/db_machdep.h
new file mode 100755
index 0000000..ae38b44
--- /dev/null
+++ b/include/machine/db_machdep.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_DB_MACHDEP_H
+#define _MACHINE_DB_MACHDEP_H
+
+#if defined (__ppc__)
+#include "ppc/db_machdep.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/db_machdep.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_DB_MACHDEP_H */
diff --git a/include/machine/endian.h b/include/machine/endian.h
new file mode 100755
index 0000000..5f9c0b9
--- /dev/null
+++ b/include/machine/endian.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_ENDIAN_H
+#define _MACHINE_ENDIAN_H
+
+#if defined (__ppc__)
+#include "ppc/endian.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/endian.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_ENDIAN_H */
diff --git a/include/machine/io_map_entries.h b/include/machine/io_map_entries.h
new file mode 100755
index 0000000..8e9e9e4
--- /dev/null
+++ b/include/machine/io_map_entries.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	KERNEL_PRIVATE
+
+#ifndef _MACHINE_IO_MAP_ENTRIES_H_
+#define _MACHINE_IO_MAP_ENTRIES_H_
+
+#if defined (__ppc__)
+#include "ppc/io_map_entries.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/io_map_entries.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_IO_MAP_ENTRIES_H_ */
+
+#endif	/* KERNEL_PRIVATE */
diff --git a/include/machine/lock.h b/include/machine/lock.h
new file mode 100755
index 0000000..558e780
--- /dev/null
+++ b/include/machine/lock.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	KERNEL_PRIVATE
+
+#ifndef _MACHINE_LOCK_H_
+#define _MACHINE_LOCK_H_
+
+#if defined (__ppc__)
+#include "ppc/lock.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/lock.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_LOCK_H_ */
+
+#endif
diff --git a/include/machine/locks.h b/include/machine/locks.h
new file mode 100755
index 0000000..7864195
--- /dev/null
+++ b/include/machine/locks.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2004-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_LOCKS_H_
+#define _MACHINE_LOCKS_H_
+
+#if defined (__ppc__)
+#include "ppc/locks.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/locks.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_LOCKS_H_ */
diff --git a/include/machine/machine_cpu.h b/include/machine/machine_cpu.h
new file mode 100755
index 0000000..fdc556a
--- /dev/null
+++ b/include/machine/machine_cpu.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_MACHINE_CPU_H
+#define _MACHINE_MACHINE_CPU_H
+
+#if defined (__ppc__)
+#include "ppc/machine_cpu.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/machine_cpu.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_MACHINE_CPU_H */
diff --git a/include/machine/machine_routines.h b/include/machine/machine_routines.h
new file mode 100755
index 0000000..a92705f
--- /dev/null
+++ b/include/machine/machine_routines.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_MACHINE_ROUTINES_H
+#define _MACHINE_MACHINE_ROUTINES_H
+
+#if defined (__ppc__)
+#include "ppc/machine_routines.h"
+#elif defined (__i386__) || defined(__x86_64__)
+#include "i386/machine_routines.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_MACHINE_ROUTINES_H */
diff --git a/include/machine/machine_rpc.h b/include/machine/machine_rpc.h
new file mode 100755
index 0000000..0fe29c9
--- /dev/null
+++ b/include/machine/machine_rpc.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_MACHINE_RPC_H
+#define _MACHINE_MACHINE_RPC_H
+
+#if defined (__ppc__)
+#include "ppc/machine_rpc.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/machine_rpc.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_MACHINE_RPC_H */
diff --git a/include/machine/machlimits.h b/include/machine/machlimits.h
new file mode 100755
index 0000000..f9d4684
--- /dev/null
+++ b/include/machine/machlimits.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_MACHLIMITS_H
+#define _MACHINE_MACHLIMITS_H
+
+#if defined (__ppc__)
+#include "ppc/machlimits.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/machlimits.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_MACHLIMITS_H */
diff --git a/include/machine/machparam.h b/include/machine/machparam.h
new file mode 100755
index 0000000..3e83253
--- /dev/null
+++ b/include/machine/machparam.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_MACHPARAM_H
+#define _MACHINE_MACHPARAM_H
+
+#if defined (__ppc__)
+#include "ppc/machparam.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/machparam.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_MACHPARAM_H */
diff --git a/include/machine/pmap.h b/include/machine/pmap.h
new file mode 100755
index 0000000..b629003
--- /dev/null
+++ b/include/machine/pmap.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_PMAP_H
+#define _MACHINE_PMAP_H
+
+#if defined (__ppc__)
+#include "ppc/pmap.h"
+#elif defined (__x86_64__) || defined (__i386__)
+#include "i386/pmap.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_PMAP_H */
diff --git a/include/machine/sched_param.h b/include/machine/sched_param.h
new file mode 100755
index 0000000..04c23c7
--- /dev/null
+++ b/include/machine/sched_param.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_SCHED_PARAM_H
+#define _MACHINE_SCHED_PARAM_H
+
+#if defined (__ppc__)
+#include "ppc/sched_param.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/sched_param.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_SCHED_PARAM_H */
diff --git a/include/machine/setjmp.h b/include/machine/setjmp.h
new file mode 100755
index 0000000..c597030
--- /dev/null
+++ b/include/machine/setjmp.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_SETJMP_H
+#define _MACHINE_SETJMP_H
+
+#if defined (__ppc__)
+#include "ppc/setjmp.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/setjmp.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_SETJMP_H */
diff --git a/include/machine/simple_lock.h b/include/machine/simple_lock.h
new file mode 100755
index 0000000..799b74c
--- /dev/null
+++ b/include/machine/simple_lock.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifdef	KERNEL_PRIVATE
+
+#ifndef _MACHINE_SIMPLE_LOCK_H_
+#define _MACHINE_SIMPLE_LOCK_H_
+
+#if defined (__ppc__)
+#include "ppc/simple_lock.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/simple_lock.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_SIMPLE_LOCK_H_ */
+
+#endif
diff --git a/include/machine/task.h b/include/machine/task.h
new file mode 100755
index 0000000..faf4ba5
--- /dev/null
+++ b/include/machine/task.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_TASK_H
+#define _MACHINE_TASK_H
+
+#if defined (__ppc__)
+#include "ppc/task.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/task.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_TASK_H */
diff --git a/include/machine/thread.h b/include/machine/thread.h
new file mode 100755
index 0000000..5eeccbd
--- /dev/null
+++ b/include/machine/thread.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_THREAD_H
+#define _MACHINE_THREAD_H
+
+#if defined (__ppc__)
+#include "ppc/thread.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/thread.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_THREADx_H */
diff --git a/include/machine/timer.h b/include/machine/timer.h
new file mode 100755
index 0000000..a80a74b
--- /dev/null
+++ b/include/machine/timer.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_TIMER_H
+#define _MACHINE_TIMER_H
+
+#if defined (__ppc__)
+#include "ppc/timer.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/timer.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_TIMER_H */
diff --git a/include/machine/trap.h b/include/machine/trap.h
new file mode 100755
index 0000000..5429870
--- /dev/null
+++ b/include/machine/trap.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_TRAP_H
+#define _MACHINE_TRAP_H
+
+#if defined (__ppc__)
+#include "ppc/trap.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/trap.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_TRAP_H */
diff --git a/include/machine/vm_tuning.h b/include/machine/vm_tuning.h
new file mode 100755
index 0000000..a5906bb
--- /dev/null
+++ b/include/machine/vm_tuning.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_VM_TUNING_H
+#define _MACHINE_VM_TUNING_H
+
+#if defined (__ppc__)
+#include "ppc/vm_tuning.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/vm_tuning.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_VM_TUNING_H */
diff --git a/include/machine/xpr.h b/include/machine/xpr.h
new file mode 100755
index 0000000..089a5cc
--- /dev/null
+++ b/include/machine/xpr.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef _MACHINE_XPR_H
+#define _MACHINE_XPR_H
+
+#if defined (__ppc__)
+#include "ppc/xpr.h"
+#elif defined (__i386__) || defined (__x86_64__)
+#include "i386/xpr.h"
+#else
+#error architecture not supported
+#endif
+
+#endif /* _MACHINE_XPR_H */
diff --git a/include/objc-shared-cache.h b/include/objc-shared-cache.h
new file mode 100755
index 0000000..b7db57d
--- /dev/null
+++ b/include/objc-shared-cache.h
@@ -0,0 +1,1363 @@
+/* 
+ * Copyright (c) 2008 Apple Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/*
+Portions derived from:
+
+--------------------------------------------------------------------
+lookup8.c, by Bob Jenkins, January 4 1997, Public Domain.
+hash(), hash2(), hash3, and mix() are externally useful functions.
+Routines to test the hash are included if SELF_TEST is defined.
+You can use this free for any purpose.  It has no warranty.
+--------------------------------------------------------------------
+
+------------------------------------------------------------------------------
+perfect.c: code to generate code for a hash for perfect hashing.
+(c) Bob Jenkins, September 1996, December 1999
+You may use this code in any way you wish, and it is free.  No warranty.
+I hereby place this in the public domain.
+Source is http://burtleburtle.net/bob/c/perfect.c
+------------------------------------------------------------------------------
+*/
+
+/*
+ * objc-selopt.h
+ * Interface between libobjc and dyld 
+ * for selector uniquing in the dyld shared cache.
+ *
+ * When building the shared cache, dyld locates all selectors and selector 
+ * references in the cached images. It builds a perfect hash table out of 
+ * them and writes the table into the shared cache copy of libobjc.
+ * libobjc then uses that table as the builtin selector list.
+ *
+ * Versioning
+ * The table has a version number. dyld and objc can both ignore the table 
+ * if the other used the wrong version number.
+ *
+ * Completeness
+ * Not all libraries are in the shared cache. Libraries that are in the 
+ * shared cache and were optimized are specially marked. Libraries on 
+ * disk never include those marks.
+ *
+ * Coherency
+ * Libraries optimized in the shared cache can be replaced by unoptimized 
+ * copies from disk when loaded. The copy from disk is not marked and will 
+ * be fixed up by libobjc. The shared cache copy is still mapped into the 
+ * process, so the table can point to cstring data in that library's part 
+ * of the shared cache without trouble.
+ * 
+ * Atomicity
+ * dyld writes the table itself last. If dyld marks some metadata as 
+ * updated but then fails to write a table for some reason, libobjc 
+ * fixes up all metadata as if it were not marked.
+ */
+
+#ifndef _OBJC_SELOPT_H
+#define _OBJC_SELOPT_H
+
+/*
+  DO NOT INCLUDE ANY objc HEADERS HERE
+  dyld USES THIS FILE AND CANNOT SEE THEM
+*/
+#include <stdint.h>
+#include <stdlib.h>
+#ifdef SELOPT_WRITE
+#include <ext/hash_map>
+#endif
+/*
+  DO NOT INCLUDE ANY objc HEADERS HERE
+  dyld USES THIS FILE AND CANNOT SEE THEM
+*/
+
+#ifndef STATIC_ASSERT
+#   define STATIC_ASSERT(x) _STATIC_ASSERT2(x, __LINE__)
+#   define _STATIC_ASSERT2(x, line) _STATIC_ASSERT3(x, line)
+#   define _STATIC_ASSERT3(x, line)                                     \
+        typedef struct {                                                \
+            int _static_assert[(x) ? 0 : -1];                           \
+        } _static_assert_ ## line __attribute__((unavailable)) 
+#endif
+
+#define SELOPT_DEBUG 0
+
+#define S32(x) x = little_endian ? OSSwapHostToLittleInt32(x) : OSSwapHostToBigInt32(x)
+#define S64(x) x = little_endian ? OSSwapHostToLittleInt64(x) : OSSwapHostToBigInt64(x)
+
+namespace objc_opt {
+
+typedef int32_t objc_stringhash_offset_t;
+typedef uint8_t objc_stringhash_check_t;
+
+#ifdef SELOPT_WRITE
+
+// Perfect hash code is at the end of this file.
+
+struct perfect_hash {
+    uint32_t capacity;
+    uint32_t occupied;
+    uint32_t shift;
+    uint32_t mask;
+    uint64_t salt;
+    
+    uint32_t scramble[256];
+    uint8_t *tab;  // count == mask+1; free with delete[]
+    
+    perfect_hash() : tab(0) { }
+    
+    ~perfect_hash() { if (tab) delete[] tab; }
+};
+
+struct eqstr {
+    bool operator()(const char* s1, const char* s2) const {
+        return strcmp(s1, s2) == 0;
+    }
+};
+
+// cstring => cstring's vmaddress
+// (used for selector names and class names)
+typedef __gnu_cxx::hash_map<const char *, uint64_t, __gnu_cxx::hash<const char *>, eqstr> string_map;
+
+// class name => (class vmaddress, header_info vmaddress)
+typedef __gnu_cxx::hash_multimap<const char *, std::pair<uint64_t, uint64_t>, __gnu_cxx::hash<const char *>, eqstr> class_map;
+
+static perfect_hash make_perfect(const string_map& strings);
+
+#endif
+
+static uint64_t lookup8( uint8_t *k, size_t length, uint64_t level);
+
+// Precomputed perfect hash table of strings.
+// Base class for precomputed selector table and class table.
+// Edit objc-sel-table.s and OPT_INITIALIZER if you change this structure.
+struct objc_stringhash_t {
+    uint32_t capacity;
+    uint32_t occupied;
+    uint32_t shift;
+    uint32_t mask;
+    uint32_t zero;
+    uint32_t unused; // alignment pad
+    uint64_t salt;
+    
+    uint32_t scramble[256];
+    uint8_t tab[0];                   /* tab[mask+1] (always power-of-2) */
+    // uint8_t checkbytes[capacity];  /* check byte for each string */
+    // int32_t offsets[capacity];     /* offsets from &capacity to cstrings */
+
+    objc_stringhash_check_t *checkbytes() { return (objc_stringhash_check_t *)&tab[mask+1]; }
+    const objc_stringhash_check_t *checkbytes() const { return (const objc_stringhash_check_t *)&tab[mask+1]; }
+
+    objc_stringhash_offset_t *offsets() { return (objc_stringhash_offset_t *)&checkbytes()[capacity]; }
+    const objc_stringhash_offset_t *offsets() const { return (const objc_stringhash_offset_t *)&checkbytes()[capacity]; }
+
+    uint32_t hash(const char *key) const
+    {
+        uint64_t val = lookup8((uint8_t*)key, strlen(key), salt);
+        uint32_t index = (uint32_t)(val>>shift) ^ scramble[tab[val&mask]];
+        return index;
+    }
+
+    // The check bytes areused to reject strings that aren't in the table
+    // without paging in the table's cstring data. This checkbyte calculation 
+    // catches 4785/4815 rejects when launching Safari; a perfect checkbyte 
+    // would catch 4796/4815.
+    objc_stringhash_check_t checkbyte(const char *key) const
+    {
+        return 
+            ((key[0] & 0x7) << 5)
+            |
+            (strlen(key) & 0x1f);
+    }
+
+#define INDEX_NOT_FOUND (~(uint32_t)0)
+
+    uint32_t getIndex(const char *key) const 
+    {
+        uint32_t h = hash(key);
+
+        // Use check byte to reject without paging in the table's cstrings
+        objc_stringhash_check_t h_check = checkbytes()[h];
+        objc_stringhash_check_t key_check = checkbyte(key);
+        bool check_fail = (h_check != key_check);
+#if ! SELOPT_DEBUG
+        if (check_fail) return INDEX_NOT_FOUND;
+#endif
+
+        const char *result = (const char *)this + offsets()[h];
+        if (0 != strcmp(key, result)) return INDEX_NOT_FOUND;
+
+#if SELOPT_DEBUG
+        if (check_fail) abort();
+#endif
+
+        return h;
+    }
+
+#ifdef SELOPT_WRITE
+
+    size_t size() 
+    {
+        return sizeof(objc_stringhash_t) 
+            + mask+1 
+            + capacity * sizeof(objc_stringhash_check_t) 
+            + capacity * sizeof(objc_stringhash_offset_t);
+    }
+
+    void byteswap(bool little_endian) 
+    {
+        // tab and checkbytes are arrays of bytes, no swap needed
+        for (uint32_t i = 0; i < 256; i++) {
+            S32(scramble[i]);
+        }
+        objc_stringhash_offset_t *o = offsets();
+        for (uint32_t i = 0; i < capacity; i++) {
+            S32(o[i]);
+        }
+        
+        S32(capacity);
+        S32(occupied);
+        S32(shift);
+        S32(mask);
+        S32(zero);
+        S64(salt);
+    }
+
+    const char *write(uint64_t base, size_t remaining, string_map& strings)
+    {        
+        if (sizeof(objc_stringhash_t) > remaining) {
+            return "selector section too small (metadata not optimized)";
+        }
+
+        if (strings.size() == 0) {
+            bzero(this, sizeof(objc_stringhash_t));
+            return NULL;
+        }
+        
+        perfect_hash phash = make_perfect(strings);
+        if (phash.capacity == 0) {
+            return "perfect hash failed (metadata not optimized)";
+        }
+
+        // Set header
+        capacity = phash.capacity;
+        occupied = phash.occupied;
+        shift = phash.shift;
+        mask = phash.mask;
+        zero = 0;
+        unused = 0;
+        salt = phash.salt;
+
+        if (size() > remaining) {
+            return "selector section too small (metadata not optimized)";
+        }
+        
+        // Set hash data
+        for (uint32_t i = 0; i < 256; i++) {
+            scramble[i] = phash.scramble[i];
+        }
+        for (uint32_t i = 0; i < phash.mask+1; i++) {
+            tab[i] = phash.tab[i];
+        }
+        
+        // Set offsets to ""
+        for (uint32_t i = 0; i < phash.capacity; i++) {
+            offsets()[i] = 
+                (objc_stringhash_offset_t)offsetof(objc_stringhash_t, zero);
+        }
+        // Set checkbytes to 0
+        for (uint32_t i = 0; i < phash.capacity; i++) {
+            checkbytes()[i] = 0;
+        }
+        
+        // Set real string offsets and checkbytes
+#       define SHIFT (64 - 8*sizeof(objc_stringhash_offset_t))
+        string_map::const_iterator s;
+        for (s = strings.begin(); s != strings.end(); ++s) {
+            int64_t offset = s->second - base;
+            if ((offset<<SHIFT)>>SHIFT != offset) {
+                return "selector offset too big (metadata not optimized)";
+            }
+
+            uint32_t h = hash(s->first);
+            offsets()[h] = (objc_stringhash_offset_t)offset;
+            checkbytes()[h] = checkbyte(s->first);
+        }
+#       undef SHIFT
+        
+        return NULL;
+    }
+
+// SELOPT_WRITE
+#endif
+};
+
+
+// Precomputed selector table.
+// Edit objc-sel-table.s and OPT_INITIALIZER if you change this structure.
+struct objc_selopt_t : objc_stringhash_t { 
+    const char *get(const char *key) const 
+    {
+        uint32_t h = getIndex(key);
+        if (h == INDEX_NOT_FOUND) return NULL;
+        
+        return (const char *)this + offsets()[h];
+    }
+};
+
+// Precomputed class list.
+// Edit objc-sel-table.s and OPT_INITIALIZER if you change these structures.
+
+struct objc_classheader_t {
+    objc_stringhash_offset_t clsOffset;
+    objc_stringhash_offset_t hiOffset;
+
+    // For duplicate class names:
+    // clsOffset = count<<1 | 1
+    // duplicated classes are duplicateOffsets[hiOffset..hiOffset+count-1]
+    bool isDuplicate() const { return clsOffset & 1; }
+    uint32_t duplicateCount() const { return clsOffset >> 1; }
+    uint32_t duplicateIndex() const { return hiOffset; }
+};
+
+
+struct objc_clsopt_t : objc_stringhash_t {
+    // ...objc_stringhash_t fields...
+    // objc_classheader_t classOffsets[capacity]; /* offsets from &capacity to class_t and header_info */
+    // uint32_t duplicateCount;
+    // objc_classheader_t duplicateOffsets[duplicatedClasses];
+
+    objc_classheader_t *classOffsets() { return (objc_classheader_t *)&offsets()[capacity]; }
+    const objc_classheader_t *classOffsets() const { return (const objc_classheader_t *)&offsets()[capacity]; }
+    
+    uint32_t& duplicateCount() { return *(uint32_t *)&classOffsets()[capacity]; }
+    const uint32_t& duplicateCount() const { return *(const uint32_t *)&classOffsets()[capacity]; }
+
+    objc_classheader_t *duplicateOffsets() { return (objc_classheader_t *)(&duplicateCount()+1); }
+    const objc_classheader_t *duplicateOffsets() const { return (const objc_classheader_t *)(&duplicateCount()+1); }
+
+    // 0/NULL/NULL: not found
+    // 1/ptr/ptr: found exactly one
+    // n/NULL/NULL:  found N - use getClassesAndHeaders() instead
+    uint32_t getClassAndHeader(const char *key, void*& cls, void*& hi) const 
+    {
+        uint32_t h = getIndex(key);
+        if (h == INDEX_NOT_FOUND) { 
+            cls = NULL;
+            hi = NULL;
+            return 0;
+        }
+
+        const objc_classheader_t& clshi = classOffsets()[h];
+        if (! clshi.isDuplicate()) {
+            // class appears in exactly one header
+            cls = (void *)((const char *)this + clshi.clsOffset);
+            hi  = (void *)((const char *)this + clshi.hiOffset);
+            return 1;
+        } 
+        else {
+            // class appears in more than one header - use getClassesAndHeaders
+            cls = NULL;
+            hi = NULL;
+            return clshi.duplicateCount();
+        }
+    }
+
+    void getClassesAndHeaders(const char *key, void **cls, void **hi) const 
+    {
+        uint32_t h = getIndex(key);
+        if (h == INDEX_NOT_FOUND) return;
+
+        const objc_classheader_t& clshi = classOffsets()[h];
+        if (! clshi.isDuplicate()) {
+            // class appears in exactly one header
+            cls[0] = (void *)((const char *)this + clshi.clsOffset);
+            hi[0]  = (void *)((const char *)this + clshi.hiOffset);
+        } 
+        else {
+            // class appears in more than one header
+            uint32_t count = clshi.duplicateCount();
+            const objc_classheader_t *list = 
+                &duplicateOffsets()[clshi.duplicateIndex()];
+            for (uint32_t i = 0; i < count; i++) {
+                cls[i] = (void *)((const char *)this + list[i].clsOffset);
+                hi[i]  = (void *)((const char *)this + list[i].hiOffset);
+            }
+        }
+    }
+
+#ifdef SELOPT_WRITE
+
+    size_t size() 
+    {
+        return
+            objc_stringhash_t::size()
+            + capacity * sizeof(objc_classheader_t)
+            + sizeof(duplicateCount())
+            + duplicateCount() * sizeof(objc_classheader_t);
+    }
+
+    void byteswap(bool little_endian) 
+    {
+        objc_classheader_t *o;
+        
+        o = classOffsets();
+        for (uint32_t i = 0; i < capacity; i++) {
+            S32(o[i].clsOffset);
+            S32(o[i].hiOffset);
+        }
+
+        o = duplicateOffsets();
+        for (uint32_t i = 0; i < duplicateCount(); i++) {
+            S32(o[i].clsOffset);
+            S32(o[i].hiOffset);
+        }
+
+        S32(duplicateCount());
+
+        objc_stringhash_t::byteswap(little_endian);
+    }
+    
+    const char *write(uint64_t base, size_t remaining, 
+                      string_map& strings, class_map& classes, bool verbose)
+    {
+        const char *err;
+        err = objc_stringhash_t::write(base, remaining, strings);
+        if (err) return err;
+
+        if (size() > remaining) {
+            return "selector section too small (metadata not optimized)";
+        }
+
+        // Set class offsets to &zero
+        objc_stringhash_offset_t zeroOffset = 
+            (objc_stringhash_offset_t)offsetof(objc_stringhash_t, zero);
+        for (uint32_t i = 0; i < capacity; i++) {
+            classOffsets()[i].clsOffset = zeroOffset;
+            classOffsets()[i].hiOffset = zeroOffset;
+        }
+        
+        // Set real class offsets
+#       define SHIFT (64 - 8*sizeof(objc_stringhash_offset_t))
+        class_map::const_iterator c;
+        for (c = classes.begin(); c != classes.end(); ++c) {
+            uint32_t h = getIndex(c->first);
+            if (h == INDEX_NOT_FOUND) {
+                return "class list busted (metadata not optimized)";
+            }
+
+            if (classOffsets()[h].clsOffset != zeroOffset) {
+                // already did this class
+                continue;
+            }
+
+            uint32_t count = classes.count(c->first);
+            if (count == 1) {
+                // only one class with this name
+
+                int64_t coff = c->second.first - base;
+                int64_t hoff = c->second.second - base;
+                if ((coff<<SHIFT)>>SHIFT != coff) {
+                    return "class offset too big (metadata not optimized)";
+                }
+                if ((hoff<<SHIFT)>>SHIFT != hoff) {
+                    return "header offset too big (metadata not optimized)";
+                }
+
+                classOffsets()[h].clsOffset = (objc_stringhash_offset_t)coff;
+                classOffsets()[h].hiOffset  = (objc_stringhash_offset_t)hoff;
+            }
+            else {
+                // class name has duplicates - write them all now
+                if (verbose) {
+                    fprintf(stderr, "update_dyld_shared_cache: %u duplicates of Objective-C class %s\n", count, c->first);
+                }
+
+                uint32_t dest = duplicateCount();
+                duplicateCount() += count;                
+                if (size() > remaining) {
+                    return "selector section too small (metadata not optimized)";
+                }
+
+                // classOffsets() instead contains count and array index
+                classOffsets()[h].clsOffset = count*2 + 1;
+                classOffsets()[h].hiOffset = dest;
+
+                std::pair<class_map::const_iterator, class_map::const_iterator>
+                    duplicates = classes.equal_range(c->first);
+                class_map::const_iterator dup;
+                for (dup = duplicates.first; dup != duplicates.second; ++dup) {
+                    int64_t coff = dup->second.first - base;
+                    int64_t hoff = dup->second.second - base;
+                    if ((coff<<SHIFT)>>SHIFT != coff) {
+                        return "class offset too big (metadata not optimized)";
+                    }
+                    if ((hoff<<SHIFT)>>SHIFT != hoff) {
+                        return "header offset too big (metadata not optimized)";
+                    }
+                    
+                    duplicateOffsets()[dest].clsOffset = (objc_stringhash_offset_t)coff;
+                    duplicateOffsets()[dest].hiOffset  = (objc_stringhash_offset_t)hoff;
+                    dest++;
+                }
+            } 
+        }
+#       undef SHIFT
+        
+        return NULL;
+    }
+
+// SELOPT_WRITE
+#endif
+};
+
+// Precomputed image list.
+struct objc_headeropt_t;
+
+// Precomputed class list.
+struct objc_clsopt_t;
+
+// Edit objc-sel-table.s if you change this value.
+enum { VERSION = 12 };
+
+// Top-level optimization structure.
+// Edit objc-sel-table.s and OPT_INITIALIZER if you change this structure.
+struct objc_opt_t {
+    uint32_t version;
+    int32_t selopt_offset;
+    int32_t headeropt_offset;
+    int32_t clsopt_offset;
+
+    const objc_selopt_t* selopt() const { 
+        if (selopt_offset == 0) return NULL;
+        return (objc_selopt_t *)((uint8_t *)this + selopt_offset);
+    }
+    objc_selopt_t* selopt() { 
+        if (selopt_offset == 0) return NULL;
+        return (objc_selopt_t *)((uint8_t *)this + selopt_offset);
+    }
+
+    struct objc_headeropt_t* headeropt() const { 
+        if (headeropt_offset == 0) return NULL;
+        return (struct objc_headeropt_t *)((uint8_t *)this + headeropt_offset);
+    }
+
+    struct objc_clsopt_t* clsopt() const { 
+        if (clsopt_offset == 0) return NULL;
+        return (objc_clsopt_t *)((uint8_t *)this + clsopt_offset);
+    }
+};
+
+// sizeof(objc_opt_t) must be pointer-aligned
+STATIC_ASSERT(sizeof(objc_opt_t) % sizeof(void*) == 0);
+
+// Initializer for empty opt of type uint32_t[].
+#define X8(x) x, x, x, x, x, x, x, x
+#define X64(x) X8(x), X8(x), X8(x), X8(x), X8(x), X8(x), X8(x), X8(x)
+#define X256(x) X64(x), X64(x), X64(x), X64(x)
+#define OPT_INITIALIZER {                                           \
+        /* objc_opt_t */                                            \
+        objc_opt::VERSION, 16, 0, 0,                                \
+        /* objc_selopt_t */                                         \
+        4, 4, 63, 3, 0, 0, 0,0, X256(0), 0, 0, 16, 16, 16, 16       \
+        /* no objc_headeropt_t */                                   \
+        /* no objc_clsopt_t */                                      \
+}
+
+
+/*
+--------------------------------------------------------------------
+mix -- mix 3 64-bit values reversibly.
+mix() takes 48 machine instructions, but only 24 cycles on a superscalar
+  machine (like Intel's new MMX architecture).  It requires 4 64-bit
+  registers for 4::2 parallelism.
+All 1-bit deltas, all 2-bit deltas, all deltas composed of top bits of
+  (a,b,c), and all deltas of bottom bits were tested.  All deltas were
+  tested both on random keys and on keys that were nearly all zero.
+  These deltas all cause every bit of c to change between 1/3 and 2/3
+  of the time (well, only 113/400 to 287/400 of the time for some
+  2-bit delta).  These deltas all cause at least 80 bits to change
+  among (a,b,c) when the mix is run either forward or backward (yes it
+  is reversible).
+This implies that a hash using mix64 has no funnels.  There may be
+  characteristics with 3-bit deltas or bigger, I didn't test for
+  those.
+--------------------------------------------------------------------
+*/
+#define mix64(a,b,c) \
+{ \
+  a -= b; a -= c; a ^= (c>>43); \
+  b -= c; b -= a; b ^= (a<<9); \
+  c -= a; c -= b; c ^= (b>>8); \
+  a -= b; a -= c; a ^= (c>>38); \
+  b -= c; b -= a; b ^= (a<<23); \
+  c -= a; c -= b; c ^= (b>>5); \
+  a -= b; a -= c; a ^= (c>>35); \
+  b -= c; b -= a; b ^= (a<<49); \
+  c -= a; c -= b; c ^= (b>>11); \
+  a -= b; a -= c; a ^= (c>>12); \
+  b -= c; b -= a; b ^= (a<<18); \
+  c -= a; c -= b; c ^= (b>>22); \
+}
+
+/*
+--------------------------------------------------------------------
+hash() -- hash a variable-length key into a 64-bit value
+  k     : the key (the unaligned variable-length array of bytes)
+  len   : the length of the key, counting by bytes
+  level : can be any 8-byte value
+Returns a 64-bit value.  Every bit of the key affects every bit of
+the return value.  No funnels.  Every 1-bit and 2-bit delta achieves
+avalanche.  About 41+5len instructions.
+
+The best hash table sizes are powers of 2.  There is no need to do
+mod a prime (mod is sooo slow!).  If you need less than 64 bits,
+use a bitmask.  For example, if you need only 10 bits, do
+  h = (h & hashmask(10));
+In which case, the hash table should have hashsize(10) elements.
+
+If you are hashing n strings (uint8_t **)k, do it like this:
+  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);
+
+By Bob Jenkins, Jan 4 1997.  bob_jenkins@burtleburtle.net.  You may
+use this code any way you wish, private, educational, or commercial,
+but I would appreciate if you give me credit.
+
+See http://burtleburtle.net/bob/hash/evahash.html
+Use for hash table lookup, or anything where one collision in 2^^64
+is acceptable.  Do NOT use for cryptographic purposes.
+--------------------------------------------------------------------
+*/
+
+static uint64_t lookup8( uint8_t *k, size_t length, uint64_t level)
+// uint8_t *k;        /* the key */
+// uint64_t  length;   /* the length of the key */
+// uint64_t  level;    /* the previous hash, or an arbitrary value */
+{
+  uint64_t a,b,c;
+  size_t len;
+
+  /* Set up the internal state */
+  len = length;
+  a = b = level;                         /* the previous hash value */
+  c = 0x9e3779b97f4a7c13LL; /* the golden ratio; an arbitrary value */
+
+  /*---------------------------------------- handle most of the key */
+  while (len >= 24)
+  {
+    a += (k[0]        +((uint64_t)k[ 1]<< 8)+((uint64_t)k[ 2]<<16)+((uint64_t)k[ 3]<<24)
+     +((uint64_t)k[4 ]<<32)+((uint64_t)k[ 5]<<40)+((uint64_t)k[ 6]<<48)+((uint64_t)k[ 7]<<56));
+    b += (k[8]        +((uint64_t)k[ 9]<< 8)+((uint64_t)k[10]<<16)+((uint64_t)k[11]<<24)
+     +((uint64_t)k[12]<<32)+((uint64_t)k[13]<<40)+((uint64_t)k[14]<<48)+((uint64_t)k[15]<<56));
+    c += (k[16]       +((uint64_t)k[17]<< 8)+((uint64_t)k[18]<<16)+((uint64_t)k[19]<<24)
+     +((uint64_t)k[20]<<32)+((uint64_t)k[21]<<40)+((uint64_t)k[22]<<48)+((uint64_t)k[23]<<56));
+    mix64(a,b,c);
+    k += 24; len -= 24;
+  }
+
+  /*------------------------------------- handle the last 23 bytes */
+  c += length;
+  switch(len)              /* all the case statements fall through */
+  {
+  case 23: c+=((uint64_t)k[22]<<56);
+  case 22: c+=((uint64_t)k[21]<<48);
+  case 21: c+=((uint64_t)k[20]<<40);
+  case 20: c+=((uint64_t)k[19]<<32);
+  case 19: c+=((uint64_t)k[18]<<24);
+  case 18: c+=((uint64_t)k[17]<<16);
+  case 17: c+=((uint64_t)k[16]<<8);
+    /* the first byte of c is reserved for the length */
+  case 16: b+=((uint64_t)k[15]<<56);
+  case 15: b+=((uint64_t)k[14]<<48);
+  case 14: b+=((uint64_t)k[13]<<40);
+  case 13: b+=((uint64_t)k[12]<<32);
+  case 12: b+=((uint64_t)k[11]<<24);
+  case 11: b+=((uint64_t)k[10]<<16);
+  case 10: b+=((uint64_t)k[ 9]<<8);
+  case  9: b+=((uint64_t)k[ 8]);
+  case  8: a+=((uint64_t)k[ 7]<<56);
+  case  7: a+=((uint64_t)k[ 6]<<48);
+  case  6: a+=((uint64_t)k[ 5]<<40);
+  case  5: a+=((uint64_t)k[ 4]<<32);
+  case  4: a+=((uint64_t)k[ 3]<<24);
+  case  3: a+=((uint64_t)k[ 2]<<16);
+  case  2: a+=((uint64_t)k[ 1]<<8);
+  case  1: a+=((uint64_t)k[ 0]);
+    /* case 0: nothing left to add */
+  }
+  mix64(a,b,c);
+  /*-------------------------------------------- report the result */
+  return c;
+}
+
+
+#ifdef SELOPT_WRITE
+
+/*
+------------------------------------------------------------------------------
+This generates a minimal perfect hash function.  That means, given a
+set of n keys, this determines a hash function that maps each of
+those keys into a value in 0..n-1 with no collisions.
+
+The perfect hash function first uses a normal hash function on the key
+to determine (a,b) such that the pair (a,b) is distinct for all
+keys, then it computes a^scramble[tab[b]] to get the final perfect hash.
+tab[] is an array of 1-byte values and scramble[] is a 256-term array of 
+2-byte or 4-byte values.  If there are n keys, the length of tab[] is a 
+power of two between n/3 and n.
+
+I found the idea of computing distinct (a,b) values in "Practical minimal 
+perfect hash functions for large databases", Fox, Heath, Chen, and Daoud, 
+Communications of the ACM, January 1992.  They found the idea in Chichelli 
+(CACM Jan 1980).  Beyond that, our methods differ.
+
+The key is hashed to a pair (a,b) where a in 0..*alen*-1 and b in
+0..*blen*-1.  A fast hash function determines both a and b
+simultaneously.  Any decent hash function is likely to produce
+hashes so that (a,b) is distinct for all pairs.  I try the hash
+using different values of *salt* until all pairs are distinct.
+
+The final hash is (a XOR scramble[tab[b]]).  *scramble* is a
+predetermined mapping of 0..255 into 0..smax-1.  *tab* is an
+array that we fill in in such a way as to make the hash perfect.
+
+First we fill in all values of *tab* that are used by more than one
+key.  We try all possible values for each position until one works.
+
+This leaves m unmapped keys and m values that something could hash to.
+If you treat unmapped keys as lefthand nodes and unused hash values
+as righthand nodes, and draw a line connecting each key to each hash
+value it could map to, you get a bipartite graph.  We attempt to
+find a perfect matching in this graph.  If we succeed, we have
+determined a perfect hash for the whole set of keys.
+
+*scramble* is used because (a^tab[i]) clusters keys around *a*.
+------------------------------------------------------------------------------
+*/
+
+typedef uint64_t  ub8;
+#define UB8MAXVAL 0xffffffffffffffffLL
+#define UB8BITS 64
+typedef uint32_t  ub4;
+#define UB4MAXVAL 0xffffffff
+#define UB4BITS 32
+typedef uint16_t  ub2;
+#define UB2MAXVAL 0xffff
+#define UB2BITS 16
+typedef uint8_t ub1;
+#define UB1MAXVAL 0xff
+#define UB1BITS 8
+
+#define TRUE  1
+#define FALSE 0
+
+#define SCRAMBLE_LEN 256 // ((ub4)1<<16)                    /* length of *scramble* */
+#define RETRY_INITKEY 2048  /* number of times to try to find distinct (a,b) */
+#define RETRY_PERFECT 4     /* number of times to try to make a perfect hash */
+
+
+/* representation of a key */
+struct key
+{
+  ub1        *name_k;                                      /* the actual key */
+  ub4         len_k;                         /* the length of the actual key */
+  ub4         hash_k;                 /* the initial hash value for this key */
+/* beyond this point is mapping-dependent */
+  ub4         a_k;                            /* a, of the key maps to (a,b) */
+  ub4         b_k;                            /* b, of the key maps to (a,b) */
+  struct key *nextb_k;                               /* next key with this b */
+};
+typedef  struct key  key;
+
+/* things indexed by b of original (a,b) pair */
+struct bstuff
+{
+  ub2  val_b;                                        /* hash=a^tabb[b].val_b */
+  key *list_b;                   /* tabb[i].list_b is list of keys with b==i */
+  ub4  listlen_b;                                        /* length of list_b */
+  ub4  water_b;           /* high watermark of who has visited this map node */
+};
+typedef  struct bstuff  bstuff;
+
+/* things indexed by final hash value */
+struct hstuff
+{
+  key *key_h;                   /* tabh[i].key_h is the key with a hash of i */
+};
+typedef  struct hstuff hstuff;
+
+/* things indexed by queue position */
+struct qstuff
+{
+  bstuff *b_q;                        /* b that currently occupies this hash */
+  ub4     parent_q;     /* queue position of parent that could use this hash */
+  ub2     newval_q;      /* what to change parent tab[b] to to use this hash */
+  ub2     oldval_q;                              /* original value of tab[b] */
+};
+typedef  struct qstuff  qstuff;
+
+
+/*
+------------------------------------------------------------------------------
+Find the mapping that will produce a perfect hash
+------------------------------------------------------------------------------
+*/
+
+/* return the ceiling of the log (base 2) of val */
+static ub4  log2u(ub4 val)
+{
+  ub4 i;
+  for (i=0; ((ub4)1<<i) < val; ++i)
+    ;
+  return i;
+}
+
+/* compute p(x), where p is a permutation of 0..(1<<nbits)-1 */
+/* permute(0)=0.  This is intended and useful. */
+static ub4  permute(ub4 x, ub4 nbits)
+// ub4 x;                                       /* input, a value in some range */
+// ub4 nbits;                                 /* input, number of bits in range */
+{
+  int i;
+  int mask   = ((ub4)1<<nbits)-1;                                /* all ones */
+  int const2 = 1+nbits/2;
+  int const3 = 1+nbits/3;
+  int const4 = 1+nbits/4;
+  int const5 = 1+nbits/5;
+  for (i=0; i<20; ++i)
+  {
+    x = (x+(x<<const2)) & mask; 
+    x = (x^(x>>const3));
+    x = (x+(x<<const4)) & mask;
+    x = (x^(x>>const5));
+  }
+  return x;
+}
+
+/* initialize scramble[] with distinct random values in 0..smax-1 */
+static void scrambleinit(ub4 *scramble, ub4 smax)
+// ub4      *scramble;                            /* hash is a^scramble[tab[b]] */
+// ub4       smax;                    /* scramble values should be in 0..smax-1 */
+{
+  ub4 i;
+
+  /* fill scramble[] with distinct random integers in 0..smax-1 */
+  for (i=0; i<SCRAMBLE_LEN; ++i)
+  {
+    scramble[i] = permute(i, log2u(smax));
+  }
+}
+
+
+/* 
+ * put keys in tabb according to key->b_k
+ * check if the initial hash might work 
+ */
+static int inittab(bstuff *tabb, ub4 blen, key *keys, ub4 nkeys, int complete)
+// bstuff   *tabb;                     /* output, list of keys with b for (a,b) */
+// ub4       blen;                                            /* length of tabb */
+// key      *keys;                               /* list of keys already hashed */
+// int       complete;        /* TRUE means to complete init despite collisions */
+{
+  int  nocollision = TRUE;
+  ub4 i;
+
+  memset((void *)tabb, 0, (size_t)(sizeof(bstuff)*blen));
+
+  /* Two keys with the same (a,b) guarantees a collision */
+  for (i = 0; i < nkeys; i++) {
+    key *mykey = keys+i;
+    key *otherkey;
+
+    for (otherkey=tabb[mykey->b_k].list_b; 
+	 otherkey; 
+	 otherkey=otherkey->nextb_k)
+    {
+      if (mykey->a_k == otherkey->a_k)
+      {
+        nocollision = FALSE;
+	if (!complete)
+	  return FALSE;
+      }
+    }
+    ++tabb[mykey->b_k].listlen_b;
+    mykey->nextb_k = tabb[mykey->b_k].list_b;
+    tabb[mykey->b_k].list_b = mykey;
+  }
+
+  /* no two keys have the same (a,b) pair */
+  return nocollision;
+}
+
+
+/* Do the initial hash for normal mode (use lookup and checksum) */
+static void initnorm(key *keys, ub4 nkeys, ub4 alen, ub4 blen, ub4 smax, ub8 salt)
+// key      *keys;                                          /* list of all keys */
+// ub4       alen;                    /* (a,b) has a in 0..alen-1, a power of 2 */
+// ub4       blen;                    /* (a,b) has b in 0..blen-1, a power of 2 */
+// ub4       smax;                   /* maximum range of computable hash values */
+// ub4       salt;                     /* used to initialize the hash function */
+// gencode  *final;                          /* output, code for the final hash */
+{
+  ub4 loga = log2u(alen);                            /* log based 2 of blen */
+  ub4 i;
+  for (i = 0; i < nkeys; i++) {
+    key *mykey = keys+i;
+    ub8 hash = lookup8(mykey->name_k, mykey->len_k, salt);
+    mykey->a_k = (loga > 0) ? hash>>(UB8BITS-loga) : 0;
+    mykey->b_k = (blen > 1) ? hash&(blen-1) : 0;
+  }
+}
+
+
+/* Try to apply an augmenting list */
+static int apply(bstuff *tabb, hstuff *tabh, qstuff *tabq, ub4 blen, ub4 *scramble, ub4 tail, int rollback)
+// bstuff *tabb;
+// hstuff *tabh;
+// qstuff *tabq;
+// ub4     blen;
+// ub4    *scramble;
+// ub4     tail;
+// int     rollback;          /* FALSE applies augmenting path, TRUE rolls back */
+{
+  ub4     hash;
+  key    *mykey;
+  bstuff *pb;
+  ub4     child;
+  ub4     parent;
+  ub4     stabb;                                         /* scramble[tab[b]] */
+
+  /* walk from child to parent */
+  for (child=tail-1; child; child=parent)
+  {
+    parent = tabq[child].parent_q;                    /* find child's parent */
+    pb     = tabq[parent].b_q;             /* find parent's list of siblings */
+
+    /* erase old hash values */
+    stabb = scramble[pb->val_b];
+    for (mykey=pb->list_b; mykey; mykey=mykey->nextb_k)
+    {
+      hash = mykey->a_k^stabb;
+      if (mykey == tabh[hash].key_h)
+      {                            /* erase hash for all of child's siblings */
+	tabh[hash].key_h = (key *)0;
+      }
+    }
+
+    /* change pb->val_b, which will change the hashes of all parent siblings */
+    pb->val_b = (rollback ? tabq[child].oldval_q : tabq[child].newval_q);
+
+    /* set new hash values */
+    stabb = scramble[pb->val_b];
+    for (mykey=pb->list_b; mykey; mykey=mykey->nextb_k)
+    {
+      hash = mykey->a_k^stabb;
+      if (rollback)
+      {
+	if (parent == 0) continue;                  /* root never had a hash */
+      }
+      else if (tabh[hash].key_h)
+      {
+	/* very rare: roll back any changes */
+        apply(tabb, tabh, tabq, blen, scramble, tail, TRUE);
+	return FALSE;                                  /* failure, collision */
+      }
+      tabh[hash].key_h = mykey;
+    }
+  }
+  return TRUE;
+}
+
+
+/*
+-------------------------------------------------------------------------------
+augment(): Add item to the mapping.
+
+Construct a spanning tree of *b*s with *item* as root, where each
+parent can have all its hashes changed (by some new val_b) with 
+at most one collision, and each child is the b of that collision.
+
+I got this from Tarjan's "Data Structures and Network Algorithms".  The
+path from *item* to a *b* that can be remapped with no collision is 
+an "augmenting path".  Change values of tab[b] along the path so that 
+the unmapped key gets mapped and the unused hash value gets used.
+
+Assuming 1 key per b, if m out of n hash values are still unused, 
+you should expect the transitive closure to cover n/m nodes before 
+an unused node is found.  Sum(i=1..n)(n/i) is about nlogn, so expect
+this approach to take about nlogn time to map all single-key b's.
+-------------------------------------------------------------------------------
+*/
+static int augment(bstuff *tabb, hstuff *tabh, qstuff *tabq, ub4 blen, ub4 *scramble, ub4 smax, bstuff *item, ub4 nkeys, 
+		   ub4 highwater)
+// bstuff   *tabb;                                        /* stuff indexed by b */
+// hstuff   *tabh;  /* which key is associated with which hash, indexed by hash */
+// qstuff   *tabq;            /* queue of *b* values, this is the spanning tree */
+// ub4       blen;                                            /* length of tabb */
+// ub4      *scramble;                      /* final hash is a^scramble[tab[b]] */
+// ub4       smax;                                 /* highest value in scramble */
+// bstuff   *item;                           /* &tabb[b] for the b to be mapped */
+// ub4       nkeys;                         /* final hash must be in 0..nkeys-1 */
+// ub4       highwater;        /* a value higher than any now in tabb[].water_b */
+{
+  ub4  q;                      /* current position walking through the queue */
+  ub4  tail;              /* tail of the queue.  0 is the head of the queue. */
+  ub4  limit=UB1MAXVAL+1;
+  ub4  highhash = smax;
+
+  /* initialize the root of the spanning tree */
+  tabq[0].b_q = item;
+  tail = 1;
+
+  /* construct the spanning tree by walking the queue, add children to tail */
+  for (q=0; q<tail; ++q)
+  {
+    bstuff *myb = tabq[q].b_q;                        /* the b for this node */
+    ub4     i;                              /* possible value for myb->val_b */
+
+    if (q == 1) 
+      break;                                  /* don't do transitive closure */
+
+    for (i=0; i<limit; ++i)
+    {
+      bstuff *childb = (bstuff *)0;             /* the b that this i maps to */
+      key    *mykey;                       /* for walking through myb's keys */
+
+      for (mykey = myb->list_b; mykey; mykey=mykey->nextb_k)
+      {
+	key    *childkey;
+	ub4 hash = mykey->a_k^scramble[i];
+
+	if (hash >= highhash) break;                        /* out of bounds */
+	childkey = tabh[hash].key_h;
+
+	if (childkey)
+	{
+	  bstuff *hitb = &tabb[childkey->b_k];
+
+	  if (childb)
+	  {
+	    if (childb != hitb) break;            /* hit at most one child b */
+	  }
+	  else
+	  {
+	    childb = hitb;                        /* remember this as childb */
+	    if (childb->water_b == highwater) break;     /* already explored */
+	  }
+	}
+      }
+      if (mykey) continue;             /* myb with i has multiple collisions */
+
+      /* add childb to the queue of reachable things */
+      if (childb) childb->water_b = highwater;
+      tabq[tail].b_q      = childb;
+      tabq[tail].newval_q = i;     /* how to make parent (myb) use this hash */
+      tabq[tail].oldval_q = myb->val_b;            /* need this for rollback */
+      tabq[tail].parent_q = q;
+      ++tail;
+
+      if (!childb)
+      {                                  /* found an *i* with no collisions? */
+	/* try to apply the augmenting path */
+	if (apply(tabb, tabh, tabq, blen, scramble, tail, FALSE))
+	  return TRUE;        /* success, item was added to the perfect hash */
+
+	--tail;                    /* don't know how to handle such a child! */
+      }
+    }
+  }
+  return FALSE;
+}
+
+
+/* find a mapping that makes this a perfect hash */
+static int perfect(bstuff *tabb, hstuff *tabh, qstuff *tabq, ub4 blen, ub4 smax, ub4 *scramble, ub4 nkeys)
+{
+  ub4 maxkeys;                           /* maximum number of keys for any b */
+  ub4 i, j;
+
+#if SELOPT_DEBUG
+  fprintf(stderr, "           blen %d smax %d nkeys %d\n", blen, smax, nkeys);
+#endif
+
+  /* clear any state from previous attempts */
+  memset((void *)tabh, 0, sizeof(hstuff)*smax);
+  memset((void *)tabq, 0, sizeof(qstuff)*(blen+1));
+
+  for (maxkeys=0,i=0; i<blen; ++i) 
+    if (tabb[i].listlen_b > maxkeys) 
+      maxkeys = tabb[i].listlen_b;
+
+  /* In descending order by number of keys, map all *b*s */
+  for (j=maxkeys; j>0; --j)
+    for (i=0; i<blen; ++i)
+      if (tabb[i].listlen_b == j)
+	if (!augment(tabb, tabh, tabq, blen, scramble, smax, &tabb[i], nkeys, 
+		     i+1))
+	{
+	  return FALSE;
+	}
+
+  /* Success!  We found a perfect hash of all keys into 0..nkeys-1. */
+  return TRUE;
+}
+
+
+/* guess initial values for alen and blen */
+static void initalen(ub4 *alen, ub4 *blen, ub4 smax, ub4 nkeys)
+// ub4      *alen;                                      /* output, initial alen */
+// ub4      *blen;                                      /* output, initial blen */
+// ub4      smax;    /* input, power of two greater or equal to max hash value */
+// ub4       nkeys;                              /* number of keys being hashed */
+{
+  /*
+   * Find initial *alen, *blen
+   * Initial alen and blen values were found empirically.  Some factors:
+   *
+   * If smax<256 there is no scramble, so tab[b] needs to cover 0..smax-1.
+   *
+   * alen and blen must be powers of 2 because the values in 0..alen-1 and
+   * 0..blen-1 are produced by applying a bitmask to the initial hash function.
+   *
+   * alen must be less than smax, in fact less than nkeys, because otherwise
+   * there would often be no i such that a^scramble[i] is in 0..nkeys-1 for
+   * all the *a*s associated with a given *b*, so there would be no legal
+   * value to assign to tab[b].  This only matters when we're doing a minimal
+   * perfect hash.
+   *
+   * It takes around 800 trials to find distinct (a,b) with nkey=smax*(5/8)
+   * and alen*blen = smax*smax/32.
+   *
+   * Values of blen less than smax/4 never work, and smax/2 always works.
+   *
+   * We want blen as small as possible because it is the number of bytes in
+   * the huge array we must create for the perfect hash.
+   *
+   * When nkey <= smax*(5/8), blen=smax/4 works much more often with 
+   * alen=smax/8 than with alen=smax/4.  Above smax*(5/8), blen=smax/4
+   * doesn't seem to care whether alen=smax/8 or alen=smax/4.  I think it
+   * has something to do with 5/8 = 1/8 * 5.  For example examine 80000, 
+   * 85000, and 90000 keys with different values of alen.  This only matters
+   * if we're doing a minimal perfect hash.
+   *
+   * When alen*blen <= 1<<UB4BITS, the initial hash must produce one integer.
+   * Bigger than that it must produce two integers, which increases the
+   * cost of the hash per character hashed.
+   */
+  *alen = smax;                     /* no reason to restrict alen to smax/2 */
+  *blen = ((nkeys <= smax*0.6) ? smax/16 : 
+           (nkeys <= smax*0.8) ? smax/8 : smax/4);
+  
+  if (*alen < 1) *alen = 1;
+  if (*blen < 1) *blen = 1;
+
+#if SELOPT_DEBUG
+  fprintf(stderr, "alen %d blen %d smax %d nkeys %d\n", *alen, *blen, smax, nkeys);
+#endif
+}
+
+/* 
+** Try to find a perfect hash function.  
+** Return the successful initializer for the initial hash. 
+** Return 0 if no perfect hash could be found.
+*/
+static int findhash(bstuff **tabb, ub4 *alen, ub4 *blen, ub8 *salt, 
+                    ub4 *scramble, ub4 smax, key *keys, ub4 nkeys)
+// bstuff  **tabb;           /* output, tab[] of the perfect hash, length *blen */
+// ub4      *alen;                 /* output, 0..alen-1 is range for a of (a,b) */
+// ub4      *blen;                 /* output, 0..blen-1 is range for b of (a,b) */
+// ub4      *salt;                         /* output, initializes initial hash */
+// ub4      *scramble;                      /* input, hash = a^scramble[tab[b]] */
+// ub4      smax;                           /* input, scramble[i] in 0..smax-1 */
+// key      *keys;                                       /* input, keys to hash */
+// ub4       nkeys;                       /* input, number of keys being hashed */
+{
+  ub4 bad_initkey;                       /* how many times did initkey fail? */
+  ub4 bad_perfect;                       /* how many times did perfect fail? */
+  ub4 si;                        /* trial initializer for initial hash */
+  ub4 maxalen;
+  hstuff *tabh;                       /* table of keys indexed by hash value */
+  qstuff *tabq;    /* table of stuff indexed by queue value, used by augment */
+
+  /* guess initial values for alen and blen */
+  initalen(alen, blen, smax, nkeys);
+
+  scrambleinit(scramble, smax);
+
+  maxalen = smax;
+
+  /* allocate working memory */
+  *tabb = new bstuff[*blen];
+  tabq  = new qstuff[*blen+1];
+  tabh  = new hstuff[smax];
+
+  /* Actually find the perfect hash */
+  *salt = 0;
+  bad_initkey = 0;
+  bad_perfect = 0;
+  for (si=1; ; ++si)
+  {
+    ub4 rslinit;
+    /* Try to find distinct (A,B) for all keys */
+    *salt = si * 0x9e3779b97f4a7c13LL; /* golden ratio (arbitrary value) */
+    initnorm(keys, nkeys, *alen, *blen, smax, *salt);
+    rslinit = inittab(*tabb, *blen, keys, nkeys, FALSE);
+    if (rslinit == 0)
+    {
+      /* didn't find distinct (a,b) */
+      if (++bad_initkey >= RETRY_INITKEY)
+      {
+	/* Try to put more bits in (A,B) to make distinct (A,B) more likely */
+	if (*alen < maxalen)
+	{
+	  *alen *= 2;
+	} 
+	else if (*blen < smax)
+	{
+	  *blen *= 2;
+	  delete[] tabq;
+	  delete[] *tabb;
+	  *tabb  = new bstuff[*blen];
+	  tabq  = new qstuff[*blen+1];
+	}
+	bad_initkey = 0;
+	bad_perfect = 0;
+      }
+      continue;                             /* two keys have same (a,b) pair */
+    }
+
+    /* Given distinct (A,B) for all keys, build a perfect hash */
+    if (!perfect(*tabb, tabh, tabq, *blen, smax, scramble, nkeys))
+    {
+      if (++bad_perfect >= RETRY_PERFECT)
+      {
+	if (*blen < smax)
+	{
+	  *blen *= 2;
+	  delete[] *tabb;
+	  delete[] tabq;
+	  *tabb  = new bstuff[*blen];
+	  tabq  = new qstuff[*blen+1];
+	  --si;               /* we know this salt got distinct (A,B) */
+	}
+	else
+	{
+          return 0;
+	}
+	bad_perfect = 0;
+      }
+      continue;
+    }
+    
+    break;
+  }
+
+  /* free working memory */
+  delete[] tabh;
+  delete[] tabq;
+
+  return 1;
+}
+
+/*
+------------------------------------------------------------------------------
+Input/output type routines
+------------------------------------------------------------------------------
+*/
+
+/* get the list of keys */
+static void getkeys(key **keys, ub4 *nkeys, const string_map& strings)
+{
+  key *buf = new key[strings.size()];
+  size_t i;
+  string_map::const_iterator s;
+  for (i = 0, s = strings.begin(); s != strings.end(); ++s, ++i) {
+    key *mykey = buf+i;
+    mykey->name_k = (ub1 *)s->first;
+    mykey->len_k  = (ub4)strlen(s->first);
+  }
+  *keys = buf;
+  *nkeys = strings.size();
+}
+
+
+static perfect_hash 
+make_perfect(const string_map& strings)
+{
+  ub4       nkeys;                                         /* number of keys */
+  key      *keys;                                    /* head of list of keys */
+  bstuff   *tab;                                       /* table indexed by b */
+  ub4       smax;            /* scramble[] values in 0..smax-1, a power of 2 */
+  ub4       alen;                            /* a in 0..alen-1, a power of 2 */
+  ub4       blen;                            /* b in 0..blen-1, a power of 2 */
+  ub8       salt;                       /* a parameter to the hash function */
+  ub4       scramble[SCRAMBLE_LEN];           /* used in final hash function */
+  int ok;
+  int i;
+  perfect_hash result;
+
+  /* read in the list of keywords */
+  getkeys(&keys, &nkeys, strings);
+
+  /* find the hash */
+  smax = ((ub4)1<<log2u(nkeys));
+  ok = findhash(&tab, &alen, &blen, &salt, 
+                scramble, smax, keys, nkeys);
+  if (!ok) {
+      smax = 2 * ((ub4)1<<log2u(nkeys));
+      ok = findhash(&tab, &alen, &blen, &salt, 
+                    scramble, smax, keys, nkeys);
+  }
+  if (!ok) {
+      bzero(&result, sizeof(result));
+  } else {
+      /* build the tables */
+      result.capacity = smax;
+      result.occupied = nkeys;
+      result.shift = UB8BITS - log2u(alen);
+      result.mask = blen - 1;
+      result.salt = salt;
+      
+      result.tab = new uint8_t[blen];
+      for (i = 0; i < blen; i++) {
+          result.tab[i] = tab[i].val_b;
+      }
+      for (i = 0; i < 256; i++) {
+          result.scramble[i] = scramble[i];
+      }
+  }
+
+  delete[] keys;
+  delete[] tab;
+
+  return result;
+}
+
+// SELOPT_WRITE
+#endif
+
+// namespace objc_selopt
+};
+
+#undef S32
+#undef S64
+
+#endif
diff --git a/include/vproc_priv.h b/include/vproc_priv.h
new file mode 100755
index 0000000..954b481
--- /dev/null
+++ b/include/vproc_priv.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_APACHE_LICENSE_HEADER_START@
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ * @APPLE_APACHE_LICENSE_HEADER_END@
+ */
+
+#ifndef __VPROC_PRIVATE_H__
+#define __VPROC_PRIVATE_H__
+
+#include <Availability.h>
+#include <sys/types.h>
+#include <sys/cdefs.h>
+#include <sys/syslog.h>
+#include <sys/time.h>
+#include <stdbool.h>
+#include <launch.h>
+#include <vproc.h>
+#include <uuid/uuid.h>
+#include <servers/bootstrap.h>
+
+#ifndef VPROC_HAS_TRANSACTIONS
+#define VPROC_HAS_TRANSACTIONS 1
+#endif
+
+__BEGIN_DECLS
+
+#define VPROCMGR_SESSION_LOGINWINDOW "LoginWindow"
+#define VPROCMGR_SESSION_BACKGROUND "Background"
+#define VPROCMGR_SESSION_AQUA "Aqua"
+#define VPROCMGR_SESSION_STANDARDIO "StandardIO"
+#define VPROCMGR_SESSION_SYSTEM "System"
+
+#define XPC_DOMAIN_TYPE_SYSTEM	 "XPCSystem"
+#define XPC_DOMAIN_TYPE_PERUSER "XPCPerUser"
+#define XPC_DOMAIN_TYPE_PERSESSION "XPCPerSession"
+#define XPC_DOMAIN_TYPE_PERAPPLICATION "XPCPerApplication"
+
+#pragma GCC visibility push(default)
+
+/* DO NOT use this. This is a hack for 'launchctl' */
+#define VPROC_MAGIC_UNLOAD_SIGNAL 0x4141504C
+
+typedef void (*_vproc_transaction_callout)(void);
+
+typedef enum {
+	VPROC_GSK_ZERO,
+	VPROC_GSK_LAST_EXIT_STATUS,
+	VPROC_GSK_GLOBAL_ON_DEMAND,
+	VPROC_GSK_MGR_UID,
+	VPROC_GSK_MGR_PID,
+	VPROC_GSK_IS_MANAGED,
+	VPROC_GSK_MGR_NAME,
+	VPROC_GSK_BASIC_KEEPALIVE,
+	VPROC_GSK_START_INTERVAL,
+	VPROC_GSK_IDLE_TIMEOUT,
+	VPROC_GSK_EXIT_TIMEOUT,
+	VPROC_GSK_ENVIRONMENT,
+	VPROC_GSK_ALLJOBS,
+	VPROC_GSK_GLOBAL_LOG_MASK,
+	VPROC_GSK_GLOBAL_UMASK,
+	VPROC_GSK_ABANDON_PROCESS_GROUP,
+	VPROC_GSK_TRANSACTIONS_ENABLED,
+	VPROC_GSK_WEIRD_BOOTSTRAP,
+	VPROC_GSK_WAITFORDEBUGGER,
+	VPROC_GSK_SECURITYSESSION,
+	VPROC_GSK_SHUTDOWN_DEBUGGING,
+	VPROC_GSK_VERBOSE_BOOT,
+	VPROC_GSK_PERUSER_SUSPEND,
+	VPROC_GSK_PERUSER_RESUME,
+	VPROC_GSK_JOB_OVERRIDES_DB,
+	VPROC_GSK_JOB_CACHE_DB,
+	VPROC_GSK_EMBEDDEDROOTEQUIVALENT,
+} vproc_gsk_t;
+
+typedef unsigned int vproc_flags_t;
+/* For _vproc_kickstart_by_label() -- instructs launchd to kickstart the job to stall before exec(2). */
+#define VPROCFLAG_STALL_JOB_EXEC	1 << 1
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
+vproc_t
+vprocmgr_lookup_vproc(const char *label);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
+vproc_t
+vproc_retain(vproc_t vp);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0)
+void
+vproc_release(vproc_t vp);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0)
+vproc_err_t
+vproc_swap_integer(vproc_t vp, vproc_gsk_t key,
+	int64_t *inval, int64_t *outval);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0)
+vproc_err_t
+vproc_swap_complex(vproc_t vp, vproc_gsk_t key,
+	launch_data_t inval, launch_data_t *outval);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_4_0)
+vproc_err_t
+vproc_swap_string(vproc_t vp, vproc_gsk_t key,
+	const char *instr, char **outstr);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA)
+vproc_err_t
+_vproc_get_last_exit_status(int *wstatus);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0)
+vproc_err_t
+_vproc_set_global_on_demand(bool val);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0)
+vproc_err_t
+_vproc_send_signal_by_label(const char *label, int sig);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0)
+vproc_err_t
+_vproc_kickstart_by_label(const char *label, pid_t *out_pid,
+	mach_port_t *out_port_name, mach_port_t *out_obsrvr_port,
+	vproc_flags_t flags);
+
+/* _vprocmgr_log_drain() is specific to syslogd. It is not for general use. */
+typedef void (*_vprocmgr_log_drain_callback_t)(struct timeval *when, pid_t 
+	from_pid, pid_t about_pid, uid_t sender_uid, gid_t sender_gid, int priority,
+	const char *from_name, const char *about_name, const char *session_name,
+	const char *msg);
+
+vproc_err_t
+_vprocmgr_log_drain(vproc_t vp, pthread_mutex_t *optional_mutex_around_callback,
+	_vprocmgr_log_drain_callback_t func);
+
+__attribute__((format(printf, 2, 3)))
+void
+_vproc_log(int pri, const char *msg, ...);
+
+__attribute__((format(printf, 2, 3)))
+void
+_vproc_log_error(int pri, const char *msg, ...);
+
+__attribute__((format(printf, 3, 0)))
+void
+_vproc_logv(int pri, int err, const char *msg, va_list ap);
+
+/* One day, we'll be able to get rid of this... */
+vproc_err_t
+_vprocmgr_move_subset_to_user(uid_t target_user, const char *session_type,
+	uint64_t flags);
+
+vproc_err_t
+_vprocmgr_switch_to_session(const char *target_session, vproc_flags_t flags);
+
+vproc_err_t
+_vprocmgr_detach_from_console(vproc_flags_t flags);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+void
+_vproc_standby_begin(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+void
+_vproc_standby_end(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+size_t
+_vproc_standby_count(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+size_t
+_vproc_standby_timeout(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+kern_return_t
+_vproc_transaction_count_for_pid(pid_t p, int32_t *count, bool *condemned);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+bool
+_vproc_pid_is_managed(pid_t p);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+void
+_vproc_transaction_try_exit(int status);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0)
+void
+_vproc_transaction_begin(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0)
+void
+_vproc_transaction_end(void);
+
+__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)
+size_t
+_vproc_transaction_count(void);
+
+int32_t *
+_vproc_transaction_ptr(void);
+
+void
+_vproc_transaction_set_callouts(_vproc_transaction_callout gone2zero, _vproc_transaction_callout gonenonzero);
+
+void
+_vproc_transactions_enable(void);
+
+#pragma GCC visibility pop
+
+__END_DECLS
+
+#endif /* __VPROC_PRIVATE_H__ */
diff --git a/objc.xcodeproj/project.pbxproj b/objc.xcodeproj/project.pbxproj
index b69a9ff..8df1474 100644
--- a/objc.xcodeproj/project.pbxproj
+++ b/objc.xcodeproj/project.pbxproj
@@ -276,6 +276,54 @@
 		83F550DF155E030800E95D3B /* objc-cache-old.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = "objc-cache-old.mm"; path = "runtime/objc-cache-old.mm"; sourceTree = "<group>"; };
 		87BB4E900EC39633005D08E1 /* objc-probes.d */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.dtrace; name = "objc-probes.d"; path = "runtime/objc-probes.d"; sourceTree = "<group>"; };
 		9672F7ED14D5F488007CEC96 /* NSObject.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = NSObject.mm; path = runtime/NSObject.mm; sourceTree = "<group>"; };
+		B3D4639A1B5E105300DB93A2 /* auto_zone.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = auto_zone.h; sourceTree = "<group>"; };
+		B3D4639B1B5E105300DB93A2 /* Block_private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = Block_private.h; sourceTree = "<group>"; };
+		B3D4639C1B5E105300DB93A2 /* CrashReporterClient.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = CrashReporterClient.h; sourceTree = "<group>"; };
+		B3D4639E1B5E105300DB93A2 /* benchmark.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = benchmark.h; sourceTree = "<group>"; };
+		B3D4639F1B5E105300DB93A2 /* private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = private.h; sourceTree = "<group>"; };
+		B3D463A01B5E105300DB93A2 /* queue_private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = queue_private.h; sourceTree = "<group>"; };
+		B3D463A11B5E105300DB93A2 /* source_private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = source_private.h; sourceTree = "<group>"; };
+		B3D463A31B5E105300DB93A2 /* OSCrossEndian.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = OSCrossEndian.h; sourceTree = "<group>"; };
+		B3D463A51B5E105300DB93A2 /* clock_reply_server.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = clock_reply_server.h; sourceTree = "<group>"; };
+		B3D463A61B5E105300DB93A2 /* exc_server.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = exc_server.h; sourceTree = "<group>"; };
+		B3D463A71B5E105300DB93A2 /* mach_exc_server.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = mach_exc_server.h; sourceTree = "<group>"; };
+		B3D463A81B5E105300DB93A2 /* notify_server.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = notify_server.h; sourceTree = "<group>"; };
+		B3D463AA1B5E105300DB93A2 /* dyld_priv.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = dyld_priv.h; sourceTree = "<group>"; };
+		B3D463AC1B5E105300DB93A2 /* asm.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = asm.h; sourceTree = "<group>"; };
+		B3D463AD1B5E105300DB93A2 /* ast.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ast.h; sourceTree = "<group>"; };
+		B3D463AE1B5E105300DB93A2 /* ast_types.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ast_types.h; sourceTree = "<group>"; };
+		B3D463AF1B5E105300DB93A2 /* commpage.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = commpage.h; sourceTree = "<group>"; };
+		B3D463B01B5E105300DB93A2 /* cpu_affinity.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_affinity.h; sourceTree = "<group>"; };
+		B3D463B11B5E105300DB93A2 /* cpu_capabilities.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_capabilities.h; sourceTree = "<group>"; };
+		B3D463B21B5E105300DB93A2 /* cpu_data.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_data.h; sourceTree = "<group>"; };
+		B3D463B31B5E105300DB93A2 /* cpu_number.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_number.h; sourceTree = "<group>"; };
+		B3D463B41B5E105300DB93A2 /* db_machdep.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = db_machdep.h; sourceTree = "<group>"; };
+		B3D463B51B5E105300DB93A2 /* endian.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = endian.h; sourceTree = "<group>"; };
+		B3D463B61B5E105300DB93A2 /* io_map_entries.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = io_map_entries.h; sourceTree = "<group>"; };
+		B3D463B71B5E105300DB93A2 /* lock.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = lock.h; sourceTree = "<group>"; };
+		B3D463B81B5E105300DB93A2 /* locks.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = locks.h; sourceTree = "<group>"; };
+		B3D463B91B5E105300DB93A2 /* machine_cpu.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = machine_cpu.h; sourceTree = "<group>"; };
+		B3D463BA1B5E105300DB93A2 /* machine_routines.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = machine_routines.h; sourceTree = "<group>"; };
+		B3D463BB1B5E105300DB93A2 /* machine_rpc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = machine_rpc.h; sourceTree = "<group>"; };
+		B3D463BC1B5E105300DB93A2 /* machlimits.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = machlimits.h; sourceTree = "<group>"; };
+		B3D463BD1B5E105300DB93A2 /* machparam.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = machparam.h; sourceTree = "<group>"; };
+		B3D463BE1B5E105300DB93A2 /* Makefile */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.make; path = Makefile; sourceTree = "<group>"; };
+		B3D463BF1B5E105300DB93A2 /* pmap.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = pmap.h; sourceTree = "<group>"; };
+		B3D463C01B5E105300DB93A2 /* sched_param.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = sched_param.h; sourceTree = "<group>"; };
+		B3D463C21B5E105300DB93A2 /* simple_lock.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = simple_lock.h; sourceTree = "<group>"; };
+		B3D463C31B5E105300DB93A2 /* task.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = task.h; sourceTree = "<group>"; };
+		B3D463C41B5E105300DB93A2 /* thread.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = thread.h; sourceTree = "<group>"; };
+		B3D463C51B5E105300DB93A2 /* timer.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = timer.h; sourceTree = "<group>"; };
+		B3D463C61B5E105300DB93A2 /* trap.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = trap.h; sourceTree = "<group>"; };
+		B3D463C71B5E105300DB93A2 /* vm_tuning.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = vm_tuning.h; sourceTree = "<group>"; };
+		B3D463C81B5E105300DB93A2 /* xpr.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = xpr.h; sourceTree = "<group>"; };
+		B3D463C91B5E105300DB93A2 /* objc-shared-cache.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "objc-shared-cache.h"; sourceTree = "<group>"; };
+		B3D463CC1B5E105300DB93A2 /* cpu_capabilities.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_capabilities.h; sourceTree = "<group>"; };
+		B3D463CE1B5E105300DB93A2 /* cpu_capabilities.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_capabilities.h; sourceTree = "<group>"; };
+		B3D463D01B5E105300DB93A2 /* cpu_capabilities.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = cpu_capabilities.h; sourceTree = "<group>"; };
+		B3D463D11B5E105300DB93A2 /* pthread_machdep.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = pthread_machdep.h; sourceTree = "<group>"; };
+		B3D463D21B5E105300DB93A2 /* vproc_priv.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = vproc_priv.h; sourceTree = "<group>"; };
+		B3D463D31B5E250E00DB93A2 /* _simple.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = _simple.h; sourceTree = "<group>"; };
 		BC07A00B0EF72D360014EC61 /* objc-auto-dump.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "objc-auto-dump.h"; path = "runtime/objc-auto-dump.h"; sourceTree = "<group>"; };
 		BC07A0100EF72D9C0014EC61 /* objc-auto-dump.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = "objc-auto-dump.mm"; path = "runtime/objc-auto-dump.mm"; sourceTree = "<group>"; };
 		BC8B5D1212D3D48100C78A5B /* libauto.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libauto.dylib; path = /usr/lib/libauto.dylib; sourceTree = "<absolute>"; };
@@ -315,6 +363,7 @@
 		08FB7794FE84155DC02AAC07 /* objc */ = {
 			isa = PBXGroup;
 			children = (
+				B3D463991B5E105300DB93A2 /* include */,
 				BC8B5D1212D3D48100C78A5B /* libauto.dylib */,
 				838485C60D6D687700CEA253 /* Public Headers */,
 				838485C70D6D688200CEA253 /* Private Headers */,
@@ -358,7 +407,6 @@
 				838485DB0D6D68A200CEA253 /* objc-lockdebug.mm */,
 				83725F4914CA5BFA0014370E /* objc-opt.mm */,
 				831C85D40E10CF850066E64C /* objc-os.mm */,
-				831C85D40E10CF850066E64C /* objc-os.mm */,
 				393CEABF0DC69E3E000B69DE /* objc-references.mm */,
 				838485E10D6D68A200CEA253 /* objc-runtime-new.mm */,
 				838485E20D6D68A200CEA253 /* objc-runtime-old.mm */,
@@ -479,6 +527,133 @@
 			name = "Project Headers";
 			sourceTree = "<group>";
 		};
+		B3D463991B5E105300DB93A2 /* include */ = {
+			isa = PBXGroup;
+			children = (
+				B3D4639A1B5E105300DB93A2 /* auto_zone.h */,
+				B3D4639B1B5E105300DB93A2 /* Block_private.h */,
+				B3D4639C1B5E105300DB93A2 /* CrashReporterClient.h */,
+				B3D4639D1B5E105300DB93A2 /* dispatch */,
+				B3D463A21B5E105300DB93A2 /* libkern */,
+				B3D463A41B5E105300DB93A2 /* mach */,
+				B3D463A91B5E105300DB93A2 /* mach-o */,
+				B3D463AB1B5E105300DB93A2 /* machine */,
+				B3D463C91B5E105300DB93A2 /* objc-shared-cache.h */,
+				B3D463CA1B5E105300DB93A2 /* System */,
+				B3D463D21B5E105300DB93A2 /* vproc_priv.h */,
+				B3D463D31B5E250E00DB93A2 /* _simple.h */,
+			);
+			path = include;
+			sourceTree = "<group>";
+		};
+		B3D4639D1B5E105300DB93A2 /* dispatch */ = {
+			isa = PBXGroup;
+			children = (
+				B3D4639E1B5E105300DB93A2 /* benchmark.h */,
+				B3D4639F1B5E105300DB93A2 /* private.h */,
+				B3D463A01B5E105300DB93A2 /* queue_private.h */,
+				B3D463A11B5E105300DB93A2 /* source_private.h */,
+			);
+			path = dispatch;
+			sourceTree = "<group>";
+		};
+		B3D463A21B5E105300DB93A2 /* libkern */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463A31B5E105300DB93A2 /* OSCrossEndian.h */,
+			);
+			path = libkern;
+			sourceTree = "<group>";
+		};
+		B3D463A41B5E105300DB93A2 /* mach */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463A51B5E105300DB93A2 /* clock_reply_server.h */,
+				B3D463A61B5E105300DB93A2 /* exc_server.h */,
+				B3D463A71B5E105300DB93A2 /* mach_exc_server.h */,
+				B3D463A81B5E105300DB93A2 /* notify_server.h */,
+			);
+			path = mach;
+			sourceTree = "<group>";
+		};
+		B3D463A91B5E105300DB93A2 /* mach-o */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463AA1B5E105300DB93A2 /* dyld_priv.h */,
+			);
+			path = "mach-o";
+			sourceTree = "<group>";
+		};
+		B3D463AB1B5E105300DB93A2 /* machine */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463AC1B5E105300DB93A2 /* asm.h */,
+				B3D463AD1B5E105300DB93A2 /* ast.h */,
+				B3D463AE1B5E105300DB93A2 /* ast_types.h */,
+				B3D463AF1B5E105300DB93A2 /* commpage.h */,
+				B3D463B01B5E105300DB93A2 /* cpu_affinity.h */,
+				B3D463B11B5E105300DB93A2 /* cpu_capabilities.h */,
+				B3D463B21B5E105300DB93A2 /* cpu_data.h */,
+				B3D463B31B5E105300DB93A2 /* cpu_number.h */,
+				B3D463B41B5E105300DB93A2 /* db_machdep.h */,
+				B3D463B51B5E105300DB93A2 /* endian.h */,
+				B3D463B61B5E105300DB93A2 /* io_map_entries.h */,
+				B3D463B71B5E105300DB93A2 /* lock.h */,
+				B3D463B81B5E105300DB93A2 /* locks.h */,
+				B3D463B91B5E105300DB93A2 /* machine_cpu.h */,
+				B3D463BA1B5E105300DB93A2 /* machine_routines.h */,
+				B3D463BB1B5E105300DB93A2 /* machine_rpc.h */,
+				B3D463BC1B5E105300DB93A2 /* machlimits.h */,
+				B3D463BD1B5E105300DB93A2 /* machparam.h */,
+				B3D463BE1B5E105300DB93A2 /* Makefile */,
+				B3D463BF1B5E105300DB93A2 /* pmap.h */,
+				B3D463C01B5E105300DB93A2 /* sched_param.h */,
+				B3D463C21B5E105300DB93A2 /* simple_lock.h */,
+				B3D463C31B5E105300DB93A2 /* task.h */,
+				B3D463C41B5E105300DB93A2 /* thread.h */,
+				B3D463C51B5E105300DB93A2 /* timer.h */,
+				B3D463C61B5E105300DB93A2 /* trap.h */,
+				B3D463C71B5E105300DB93A2 /* vm_tuning.h */,
+				B3D463C81B5E105300DB93A2 /* xpr.h */,
+			);
+			path = machine;
+			sourceTree = "<group>";
+		};
+		B3D463CA1B5E105300DB93A2 /* System */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463CB1B5E105300DB93A2 /* i386 */,
+				B3D463CD1B5E105300DB93A2 /* machine */,
+				B3D463CF1B5E105300DB93A2 /* ppc */,
+				B3D463D11B5E105300DB93A2 /* pthread_machdep.h */,
+			);
+			path = System;
+			sourceTree = "<group>";
+		};
+		B3D463CB1B5E105300DB93A2 /* i386 */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463CC1B5E105300DB93A2 /* cpu_capabilities.h */,
+			);
+			path = i386;
+			sourceTree = "<group>";
+		};
+		B3D463CD1B5E105300DB93A2 /* machine */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463CE1B5E105300DB93A2 /* cpu_capabilities.h */,
+			);
+			path = machine;
+			sourceTree = "<group>";
+		};
+		B3D463CF1B5E105300DB93A2 /* ppc */ = {
+			isa = PBXGroup;
+			children = (
+				B3D463D01B5E105300DB93A2 /* cpu_capabilities.h */,
+			);
+			path = ppc;
+			sourceTree = "<group>";
+		};
 /* End PBXGroup section */
 
 /* Begin PBXHeadersBuildPhase section */
@@ -873,6 +1048,10 @@
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_MODEL_TUNING = G5;
 				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"OS_OBJECT_USE_OBJC=0",
+					LIBC_NO_LIBCRASHREPORTERCLIENT,
+				);
 				GCC_THREADSAFE_STATICS = NO;
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
 				HEADER_SEARCH_PATHS = (
@@ -880,9 +1059,10 @@
 					"$(DSTROOT)/usr/local/include/**",
 					"$(CONFIGURATION_BUILD_DIR)/usr/include/**",
 					"$(CONFIGURATION_BUILD_DIR)/usr/local/include/**",
+					"$(SRCROOT)/include",
 				);
 				INSTALL_PATH = /usr/lib;
-				ORDER_FILE = "$(SDKROOT)/AppleInternal/OrderFiles/libobjc.order";
+				ORDER_FILE = libobjc.order;
 				OTHER_CFLAGS = (
 					"-fdollars-in-identifiers",
 					"$(OTHER_CFLAGS)",
@@ -890,14 +1070,27 @@
 				"OTHER_LDFLAGS[sdk=iphoneos*][arch=*]" = (
 					"-lc++abi",
 					"-Wl,-segalign,0x4000",
-					"-Xlinker -sectalign -Xlinker __DATA -Xlinker __objc_data -Xlinker 0x1000",
+					"-Xlinker",
+					"-sectalign",
+					"-Xlinker",
+					__DATA,
+					"-Xlinker",
+					__objc_data,
+					"-Xlinker",
+					0x1000,
 				);
 				"OTHER_LDFLAGS[sdk=iphonesimulator*][arch=*]" = "-l_BUILD_objc-simulator_TARGET_INSTEAD";
 				"OTHER_LDFLAGS[sdk=macosx*]" = (
-					"-lCrashReporterClient",
 					"-lauto",
 					"-lc++abi",
-					"-Xlinker -sectalign -Xlinker __DATA -Xlinker __objc_data -Xlinker 0x1000",
+					"-Xlinker",
+					"-sectalign",
+					"-Xlinker",
+					__DATA,
+					"-Xlinker",
+					__objc_data,
+					"-Xlinker",
+					0x1000,
 				);
 				PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/objc;
 				PRODUCT_NAME = objc.A;
@@ -912,6 +1105,11 @@
 				DYLIB_CURRENT_VERSION = 228;
 				EXECUTABLE_PREFIX = lib;
 				GCC_CW_ASM_SYNTAX = NO;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"OS_OBJECT_USE_OBJC=0",
+					"NDEBUG=1",
+					LIBC_NO_LIBCRASHREPORTERCLIENT,
+				);
 				GCC_THREADSAFE_STATICS = NO;
 				GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = NO;
 				HEADER_SEARCH_PATHS = (
@@ -919,9 +1117,10 @@
 					"$(DSTROOT)/usr/local/include/**",
 					"$(CONFIGURATION_BUILD_DIR)/usr/include/**",
 					"$(CONFIGURATION_BUILD_DIR)/usr/local/include/**",
+					"$(SRCROOT)/include",
 				);
 				INSTALL_PATH = /usr/lib;
-				ORDER_FILE = "$(SDKROOT)/AppleInternal/OrderFiles/libobjc.order";
+				ORDER_FILE = libobjc.order;
 				OTHER_CFLAGS = (
 					"-fdollars-in-identifiers",
 					"$(OTHER_CFLAGS)",
@@ -929,14 +1128,27 @@
 				"OTHER_LDFLAGS[sdk=iphoneos*][arch=*]" = (
 					"-lc++abi",
 					"-Wl,-segalign,0x4000",
-					"-Xlinker -sectalign -Xlinker __DATA -Xlinker __objc_data -Xlinker 0x1000",
+					"-Xlinker",
+					"-sectalign",
+					"-Xlinker",
+					__DATA,
+					"-Xlinker",
+					__objc_data,
+					"-Xlinker",
+					0x1000,
 				);
 				"OTHER_LDFLAGS[sdk=iphonesimulator*][arch=*]" = "-l_BUILD_objc-simulator_TARGET_INSTEAD";
 				"OTHER_LDFLAGS[sdk=macosx*]" = (
-					"-lCrashReporterClient",
 					"-lauto",
 					"-lc++abi",
-					"-Xlinker -sectalign -Xlinker __DATA -Xlinker __objc_data -Xlinker 0x1000",
+					"-Xlinker",
+					"-sectalign",
+					"-Xlinker",
+					__DATA,
+					"-Xlinker",
+					__objc_data,
+					"-Xlinker",
+					0x1000,
 				);
 				PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/objc;
 				PRODUCT_NAME = objc.A;
diff --git a/objc.xcodeproj/project.xcworkspace/xcuserdata/huangjl.xcuserdatad/UserInterfaceState.xcuserstate b/objc.xcodeproj/project.xcworkspace/xcuserdata/huangjl.xcuserdatad/UserInterfaceState.xcuserstate
index 53843a8..fb19508 100644
Binary files a/objc.xcodeproj/project.xcworkspace/xcuserdata/huangjl.xcuserdatad/UserInterfaceState.xcuserstate and b/objc.xcodeproj/project.xcworkspace/xcuserdata/huangjl.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/runtime/objc-os.h b/runtime/objc-os.h
index 52b2ef5..03eb563 100644
--- a/runtime/objc-os.h
+++ b/runtime/objc-os.h
@@ -86,12 +86,21 @@ static inline size_t word_align(size_t x) {
 #   include <mach-o/getsect.h>
 #   include <mach-o/dyld_priv.h>
 #   include <malloc/malloc.h>
-#   include <os/lock_private.h>
+//#   include <os/lock_private.h>
 #   include <libkern/OSAtomic.h>
 #   include <libkern/OSCacheControl.h>
-#   include <System/pthread_machdep.h>
+//#   include <System/pthread_machdep.h>
 #   include "objc-probes.h"  // generated dtrace probe definitions.
 
+#define __PTK_FRAMEWORK_OBJC_KEY5 45
+#define __PTK_FRAMEWORK_OBJC_KEY6 46
+#define __PTK_FRAMEWORK_OBJC_KEY7 47
+#define __PTK_FRAMEWORK_OBJC_KEY8 48
+#define __PTK_FRAMEWORK_OBJC_KEY9 49
+
+extern "C" int pthread_key_init_np(int, void (*)(void *));
+
+
 // Some libc functions call objc_msgSend() 
 // so we can't use them without deadlocks.
 void syslog(int, const char *, ...) UNAVAILABLE_ATTRIBUTE;
@@ -208,12 +217,51 @@ StoreReleaseExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)
 #endif
 
 
-#define spinlock_t os_lock_handoff_s
-#define spinlock_trylock(l) os_lock_trylock(l)
-#define spinlock_lock(l) os_lock_lock(l)
-#define spinlock_unlock(l) os_lock_unlock(l)
-#define SPINLOCK_INITIALIZER OS_LOCK_HANDOFF_INIT
-
+#if defined(__i386__) || defined(__x86_64__)
+// Inlined spinlock.
+// Not for arm on iOS because it hurts uniprocessor performance.
+#define ARR_SPINLOCK_INIT 0
+// XXX -- Careful: OSSpinLock isn't volatile, but should be
+typedef volatile int ARRSpinLock;
+__attribute__((always_inline))
+static inline void ARRSpinLockLock(ARRSpinLock *l)
+{
+    unsigned y;
+again:
+    if (__builtin_expect(__sync_lock_test_and_set(l, 1), 0) == 0) {
+        return;
+    }
+    for (y = 1000; y; y--) {
+#if defined(__i386__) || defined(__x86_64__)
+        asm("pause");
+#endif
+        if (*l == 0) goto again;
+    }
+    thread_switch(THREAD_NULL, SWITCH_OPTION_DEPRESS, 1);
+    goto again;
+}
+__attribute__((always_inline))
+static inline void ARRSpinLockUnlock(ARRSpinLock *l)
+{
+    __sync_lock_release(l);
+}
+__attribute__((always_inline))
+static inline int ARRSpinLockTry(ARRSpinLock *l)
+{
+    return __sync_bool_compare_and_swap(l, 0, 1);
+}
+#define spinlock_t ARRSpinLock
+#define spinlock_trylock(l) ARRSpinLockTry(l)
+#define spinlock_lock(l) ARRSpinLockLock(l)
+#define spinlock_unlock(l) ARRSpinLockUnlock(l)
+#define SPINLOCK_INITIALIZER ARR_SPINLOCK_INIT
+
+//#define spinlock_t os_lock_handoff_s
+//#define spinlock_trylock(l) os_lock_trylock(l)
+//#define spinlock_lock(l) os_lock_lock(l)
+//#define spinlock_unlock(l) os_lock_unlock(l)
+//#define SPINLOCK_INITIALIZER OS_LOCK_HANDOFF_INIT
+#endif
 
 #if !TARGET_OS_IPHONE
 #   include <CrashReporterClient.h>
@@ -713,21 +761,13 @@ static inline void *tls_get_direct(tls_key_t k)
 { 
     assert(is_valid_direct_key(k));
 
-    if (_pthread_has_direct_tsd()) {
-        return _pthread_getspecific_direct(k);
-    } else {
-        return pthread_getspecific(k);
-    }
+    return pthread_getspecific(k);
 }
 static inline void tls_set_direct(tls_key_t k, void *value) 
 { 
     assert(is_valid_direct_key(k));
 
-    if (_pthread_has_direct_tsd()) {
-        _pthread_setspecific_direct(k, value);
-    } else {
-        pthread_setspecific(k, value);
-    }
+    pthread_setspecific(k, value);
 }
 
 // not arm
